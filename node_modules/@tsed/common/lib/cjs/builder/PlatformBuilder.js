"use strict";
var _PlatformBuilder_injector, _PlatformBuilder_rootModule, _PlatformBuilder_adapter, _PlatformBuilder_promise, _PlatformBuilder_servers, _PlatformBuilder_listeners;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformBuilder = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const platform_middlewares_1 = require("@tsed/platform-middlewares");
const Platform_1 = require("../services/Platform");
const PlatformApplication_1 = require("../services/PlatformApplication");
const getStaticsOptions_1 = require("../utils/getStaticsOptions");
const getConfiguration_1 = require("../utils/getConfiguration");
const PlatformAdapter_1 = require("../services/PlatformAdapter");
const createInjector_1 = require("../utils/createInjector");
const GlobalAcceptMimesMiddleware_1 = require("../middlewares/GlobalAcceptMimesMiddleware");
const printRoutes_1 = require("../utils/printRoutes");
const createHttpServer_1 = require("../utils/createHttpServer");
const createHttpsServer_1 = require("../utils/createHttpsServer");
/**
 * @platform
 */
class PlatformBuilder {
    constructor(adapter, module, settings) {
        this.name = "";
        this.startedAt = new Date();
        this.current = new Date();
        _PlatformBuilder_injector.set(this, void 0);
        _PlatformBuilder_rootModule.set(this, void 0);
        _PlatformBuilder_adapter.set(this, void 0);
        _PlatformBuilder_promise.set(this, void 0);
        _PlatformBuilder_servers.set(this, void 0);
        _PlatformBuilder_listeners.set(this, []);
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_rootModule, module, "f");
        const configuration = (0, getConfiguration_1.getConfiguration)(settings, module);
        const adapterKlass = adapter || PlatformBuilder.adapter;
        const name = (0, core_1.nameOf)(adapterKlass).replace("Platform", "").toLowerCase();
        configuration.PLATFORM_NAME = name;
        this.name = name;
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_injector, (0, createInjector_1.createInjector)({
            adapter: adapterKlass,
            settings: configuration
        }), "f");
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_adapter, tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_injector, "f").get(PlatformAdapter_1.PlatformAdapter), "f");
        this.createHttpServers();
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").onInit && tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").onInit();
        this.log("Injector created...");
    }
    get injector() {
        return tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_injector, "f");
    }
    get rootModule() {
        return tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_injector, "f").get(tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_rootModule, "f"));
    }
    get app() {
        return this.injector.get(PlatformApplication_1.PlatformApplication);
    }
    get platform() {
        return this.injector.get(Platform_1.Platform);
    }
    get adapter() {
        return tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f");
    }
    /**
     * Return the settings configured by the decorator @@Configuration@@.
     *
     * ```typescript
     * @Configuration({
     *    rootDir: Path.resolve(__dirname),
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {PlatformConfiguration}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    get disableBootstrapLog() {
        var _a;
        return (_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.disableBootstrapLog;
    }
    static create(module, settings) {
        return this.build(module, {
            httpsPort: false,
            httpPort: false,
            ...settings,
            disableComponentsScan: true
        });
    }
    static build(module, { adapter, ...settings }) {
        return new PlatformBuilder(adapter, module, settings);
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static async bootstrap(module, settings) {
        const configuration = (0, getConfiguration_1.getConfiguration)(settings, module);
        const disableComponentsScan = configuration.disableComponentsScan || !!process.env.WEBPACK;
        if (!disableComponentsScan) {
            const { importProviders } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/components-scan")));
            await importProviders(configuration);
        }
        return this.build(module, configuration).bootstrap();
    }
    callback(req, res) {
        if (req && res) {
            return this.app.callback()(req, res);
        }
        return this.app.callback();
    }
    log(...data) {
        return !this.disableBootstrapLog && this.logger.info(...data, this.diff());
    }
    /**
     * Add classes to the components list
     * @param classes
     * @deprecated
     */
    addComponents(classes) {
        this.settings.componentsScan = this.settings.componentsScan.concat(classes);
        return this;
    }
    /**
     * Add classes decorated by @@Controller@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * platform.addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     */
    addControllers(endpoint, controllers) {
        [].concat(controllers).forEach((token) => {
            this.settings.routes.push({ token, route: endpoint });
        });
    }
    async runLifecycle() {
        (0, di_1.setLoggerLevel)(this.injector);
        await this.loadInjector();
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useContext && tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useContext();
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useRouter && tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useRouter();
        await this.loadRoutes();
        await this.logRoutes();
        return this;
    }
    async loadInjector() {
        const { injector } = this;
        this.log("Build providers");
        await injector.loadModule(tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_rootModule, "f"));
        this.log("Settings and injector loaded...");
        await this.callHook("$afterInit");
    }
    async listen(network = true) {
        if (!tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_promise, "f")) {
            await this.bootstrap();
        }
        await this.callHook("$beforeListen");
        if (network) {
            await this.listenServers();
        }
        await this.callHook("$afterListen");
        await this.ready();
    }
    async stop() {
        await this.callHook("$onDestroy");
        await this.injector.destroy();
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_listeners, "f").map((server) => {
            return new Promise((resolve) => server.close(() => resolve(undefined)));
        });
    }
    async ready() {
        const { startedAt } = this;
        await this.callHook("$onReady");
        await this.injector.emit("$onServerReady");
        this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
    }
    async callHook(hook, ...args) {
        const { injector } = this;
        if (!this.disableBootstrapLog) {
            injector.logger.debug(`\x1B[1mCall hook ${hook}\x1B[22m`);
        }
        // Load middlewares for the given hook
        this.loadMiddlewaresFor(hook);
        // call hooks added by providers
        await injector.emit(hook, ...args);
    }
    async loadStatics(hook) {
        const statics = this.settings.get("statics");
        (0, getStaticsOptions_1.getStaticsOptions)(statics).forEach(({ path, options }) => {
            if (options.hook === hook) {
                this.platform.app.statics(path, options);
            }
        });
    }
    useProvider(token, settings) {
        this.injector.addProvider(token, settings);
        return this;
    }
    async bootstrap() {
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_promise, tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_promise, "f") || this.runLifecycle(), "f");
        return tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_promise, "f");
    }
    async loadRoutes() {
        var _a, _b;
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").beforeLoadRoutes && (await tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").beforeLoadRoutes());
        // istanbul ignore next
        if (((_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.level) !== "off") {
            const { PlatformLogMiddleware } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/platform-log-middleware")));
            this.app.use(PlatformLogMiddleware);
        }
        if ((_b = this.settings.acceptMimes) === null || _b === void 0 ? void 0 : _b.length) {
            this.app.use(GlobalAcceptMimesMiddleware_1.GlobalAcceptMimesMiddleware);
        }
        this.log("Load routes");
        if (this.rootModule.$beforeRoutesInit) {
            await this.rootModule.$beforeRoutesInit();
            this.rootModule.$beforeRoutesInit = () => { };
        }
        await this.loadStatics("$beforeRoutesInit");
        await this.callHook("$beforeRoutesInit");
        const routes = this.injector.settings.get("routes");
        this.platform.addRoutes(routes);
        await this.callHook("$onRoutesInit");
        await this.loadStatics("$afterRoutesInit");
        await this.callHook("$afterRoutesInit");
        tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").afterLoadRoutes && (await tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").afterLoadRoutes());
    }
    diff() {
        const ms = di_1.colors.yellow(`+${new Date().getTime() - this.current.getTime()}ms`);
        this.current = new Date();
        return ms;
    }
    /**
     * Load middlewares from configuration for the given hook
     * @param hook
     * @protected
     */
    loadMiddlewaresFor(hook) {
        return (0, platform_middlewares_1.getMiddlewaresForHook)(hook, this.settings, "$beforeRoutesInit").forEach(({ use }) => {
            this.app.use(use);
        });
    }
    createHttpServers() {
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_servers, [(0, createHttpServer_1.createHttpServer)(tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_injector, "f"), this.callback()), (0, createHttpsServer_1.createHttpsServer)(tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_injector, "f"), this.callback())].filter(Boolean), "f");
    }
    async listenServers() {
        tslib_1.__classPrivateFieldSet(this, _PlatformBuilder_listeners, await Promise.all(tslib_1.__classPrivateFieldGet(this, _PlatformBuilder_servers, "f").map((cb) => cb && cb())), "f");
    }
    async logRoutes() {
        var _a;
        const { logger, platform } = this;
        this.log("Routes mounted...");
        if (!((_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.disableRoutesSummary) && !this.disableBootstrapLog) {
            logger.info((0, printRoutes_1.printRoutes)(await this.injector.alterAsync("$logRoutes", platform.getRoutes())));
        }
    }
}
exports.PlatformBuilder = PlatformBuilder;
_PlatformBuilder_injector = new WeakMap(), _PlatformBuilder_rootModule = new WeakMap(), _PlatformBuilder_adapter = new WeakMap(), _PlatformBuilder_promise = new WeakMap(), _PlatformBuilder_servers = new WeakMap(), _PlatformBuilder_listeners = new WeakMap();
//# sourceMappingURL=PlatformBuilder.js.map