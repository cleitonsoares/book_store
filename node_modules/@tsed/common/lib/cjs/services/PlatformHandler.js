"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformHandler = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const logger_1 = require("@tsed/logger");
const platform_params_1 = require("@tsed/platform-params");
const platform_response_filter_1 = require("@tsed/platform-response-filter");
const AnyToPromiseWithCtx_1 = require("../domain/AnyToPromiseWithCtx");
const HandlerMetadata_1 = require("../domain/HandlerMetadata");
const HandlerType_1 = require("../interfaces/HandlerType");
const createHandlerMetadata_1 = require("../utils/createHandlerMetadata");
const setResponseHeaders_1 = require("../utils/setResponseHeaders");
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    constructor(injector, params) {
        this.injector = injector;
        this.params = params;
    }
    /**
     * Create a native middleware based on the given metadata and return an instance of AnyToPromiseWithCtx
     * @param input
     * @param options
     */
    createHandler(input, options = {}) {
        return this.createRawHandler((0, createHandlerMetadata_1.createHandlerMetadata)(this.injector, input, options));
    }
    /**
     * Create injectable handler from the given provider
     * @param provider
     * @param propertyKey
     */
    createCustomHandler(provider, propertyKey) {
        const handler = this.compileHandler(new HandlerMetadata_1.HandlerMetadata({
            token: provider.provide,
            target: provider.useClass,
            type: HandlerType_1.HandlerType.CUSTOM,
            scope: provider.scope,
            propertyKey
        }));
        return async ($ctx, next) => handler({
            $ctx,
            next
        });
    }
    /**
     * Send the response to the consumer.
     * @param data
     * @param ctx
     * @protected
     */
    async flush(data, ctx) {
        const { response } = ctx;
        if (!response.isDone()) {
            data = await this.responseFilter.serialize(data, ctx);
            data = await this.responseFilter.transform(data, ctx);
            response.body(data);
        }
    }
    compileHandler(metadata) {
        if (metadata.type === HandlerType_1.HandlerType.CTX_FN) {
            return async (scope) => {
                // @ts-ignore
                return this.onCtxRequest({
                    ...scope,
                    handler: () => metadata.handler(scope.$ctx),
                    metadata
                });
            };
        }
        const promise = this.params.compileHandler({
            token: metadata.token,
            propertyKey: metadata.propertyKey,
            getCustomArgs: metadata.injectable ? undefined : this.getDefaultArgs(metadata)
        });
        return async (scope) => {
            const handler = await promise;
            // @ts-ignore
            return this.onRequest({
                ...scope,
                handler,
                metadata
            });
        };
    }
    async onCtxRequest(requestOptions) {
        await requestOptions.handler(requestOptions);
        return this.next(requestOptions);
    }
    /**
     * Call handler when a request his handle
     * @param requestOptions
     */
    async onRequest(requestOptions) {
        const { $ctx, metadata, err, handler } = requestOptions;
        // istanbul ignore next
        if (!$ctx || $ctx.isDone()) {
            logger_1.$log.error({
                name: "HEADERS_SENT",
                message: `An endpoint is called but the response is already send to the client. The call comes from the handler: ${metadata.toString()}`
            });
            return;
        }
        const resolver = new AnyToPromiseWithCtx_1.AnyToPromiseWithCtx({ $ctx, err });
        return (0, di_1.runInContext)($ctx, async () => {
            try {
                const { state, data, status, headers } = await resolver.call(handler);
                if (state === core_1.AnyToPromiseStatus.RESOLVED) {
                    if (status) {
                        $ctx.response.status(status);
                    }
                    if (headers) {
                        $ctx.response.setHeaders(headers);
                    }
                    if (data !== undefined) {
                        $ctx.data = data;
                    }
                    // Can be canceled by the handler itself
                    return await this.onSuccess($ctx.data, requestOptions);
                }
            }
            catch (er) {
                return this.onError(er, requestOptions);
            }
        });
    }
    async onError(er, requestOptions) {
        const { next, $ctx, metadata } = requestOptions;
        if ($ctx) {
            $ctx.data = er;
        }
        if (!next) {
            throw er;
        }
        // istanbul ignore next
        if (!$ctx || $ctx.isDone()) {
            logger_1.$log.warn({
                name: "HEADERS_SENT",
                message: `An error was caught after the headers were sent to the client. The error comes from the handler: ${metadata.toString()}`,
                stack: er.stack,
                origin: er,
                request_id: $ctx === null || $ctx === void 0 ? void 0 : $ctx.id
            });
            return;
        }
        return next(er);
    }
    /**
     * Manage success scenario
     * @param data
     * @param requestOptions
     * @protected
     */
    async onSuccess(data, requestOptions) {
        const { metadata, $ctx, next } = requestOptions;
        // istanbul ignore next
        if ($ctx === null || $ctx === void 0 ? void 0 : $ctx.isDone()) {
            return;
        }
        // set headers each times that an endpoint is called
        if (metadata.type === HandlerType_1.HandlerType.ENDPOINT) {
            this.setHeaders($ctx);
        }
        // call returned middleware
        if ((0, core_1.isFunction)(data) && !(0, core_1.isStream)(data)) {
            return this.callReturnedMiddleware(data, $ctx, next);
        }
        if (metadata.isFinal()) {
            return this.flush(data, $ctx);
        }
        return this.next(requestOptions);
    }
    /**
     * Call the returned middleware by the handler.
     * @param middleware
     * @param ctx
     * @param next
     * @protected
     */
    callReturnedMiddleware(middleware, ctx, next) {
        return middleware(ctx.getRequest(), ctx.getResponse(), next);
    }
    /**
     * create Raw handler
     * @param metadata
     */
    createRawHandler(metadata) {
        if ([HandlerType_1.HandlerType.RAW_ERR_FN, HandlerType_1.HandlerType.RAW_FN].includes(metadata.type)) {
            return metadata.handler;
        }
        const handler = this.compileHandler(metadata);
        return async (request, response, next) => {
            return handler({
                next,
                $ctx: request.$ctx
            });
        };
    }
    /**
     * Set response headers
     * @param ctx
     * @protected
     */
    setHeaders(ctx) {
        return (0, setResponseHeaders_1.setResponseHeaders)(ctx);
    }
    next(requestOptions) {
        const { $ctx, next } = requestOptions;
        return !$ctx.response.isDone() && next && next();
    }
    getDefaultArgs(metadata) {
        return async (scope) => [
            metadata.hasErrorParam && scope.err,
            scope.$ctx.request.request,
            scope.$ctx.response.response,
            metadata.hasNextFunction && scope.next
        ].filter(Boolean);
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_response_filter_1.PlatformResponseFilter)
], PlatformHandler.prototype, "responseFilter", void 0);
PlatformHandler = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService, platform_params_1.PlatformParams])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map