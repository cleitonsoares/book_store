"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformMiddlewaresChain = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const platform_params_1 = require("@tsed/platform-params");
const schema_1 = require("@tsed/schema");
const bindEndpointMiddleware_1 = require("../middlewares/bindEndpointMiddleware");
const PlatformAcceptMimesMiddleware_1 = require("../middlewares/PlatformAcceptMimesMiddleware");
const PlatformMulterMiddleware_1 = require("../middlewares/PlatformMulterMiddleware");
const useCtxHandler_1 = require("../utils/useCtxHandler");
const PlatformAdapter_1 = require("../services/PlatformAdapter");
const core_1 = require("@tsed/core");
let PlatformMiddlewaresChain = class PlatformMiddlewaresChain {
    get(provider, operationRoute, parentMiddlewares = []) {
        const { endpoint } = operationRoute;
        const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares } = endpoint;
        const { middlewares: { useBefore, use, useAfter } } = provider;
        const allMiddlewares = [
            ...parentMiddlewares,
            ...useBefore,
            ...beforeMiddlewares,
            ...use,
            ...mldwrs,
            endpoint,
            ...afterMiddlewares,
            ...useAfter
        ];
        const { ACCEPT_MIMES, FILE, RAW_BODY, BODY } = this.getParamTypes(allMiddlewares, operationRoute);
        return [
            (0, useCtxHandler_1.useCtxHandler)((0, bindEndpointMiddleware_1.bindEndpointMiddleware)(endpoint)),
            ACCEPT_MIMES && PlatformAcceptMimesMiddleware_1.PlatformAcceptMimesMiddleware,
            FILE && PlatformMulterMiddleware_1.PlatformMulterMiddleware,
            !FILE && RAW_BODY && this.adapter.bodyParser("raw"),
            !FILE && !RAW_BODY && BODY && this.adapter.bodyParser("json"),
            !FILE && !RAW_BODY && BODY && this.adapter.bodyParser("urlencoded"),
            ...allMiddlewares
        ].filter(Boolean);
    }
    hasAcceptMimes(operationRoute) {
        return operationRoute.endpoint.acceptMimes.length || this.acceptMimes.length;
    }
    getParamTypes(middlewares, operationRoute) {
        return middlewares.filter(core_1.isClass).reduce((paramTypes, token) => {
            if (token !== operationRoute.endpoint) {
                const entity = schema_1.JsonEntityStore.fromMethod(token, "use");
                if (entity.decoratorType === "method") {
                    const { FILE, RAW_BODY, BODY } = entity.getParamTypes();
                    paramTypes.FILE = paramTypes.FILE || FILE;
                    paramTypes.RAW_BODY = paramTypes.RAW_BODY || RAW_BODY;
                    paramTypes.BODY = paramTypes.BODY || BODY;
                }
            }
            return paramTypes;
        }, {
            ACCEPT_MIMES: this.hasAcceptMimes(operationRoute),
            FILE: operationRoute.has(platform_params_1.ParamTypes.FILES),
            RAW_BODY: operationRoute.has(platform_params_1.ParamTypes.RAW_BODY),
            BODY: operationRoute.has(platform_params_1.ParamTypes.BODY)
        });
    }
};
tslib_1.__decorate([
    (0, di_1.Constant)("acceptMimes", []),
    tslib_1.__metadata("design:type", Array)
], PlatformMiddlewaresChain.prototype, "acceptMimes", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformAdapter_1.PlatformAdapter)
], PlatformMiddlewaresChain.prototype, "adapter", void 0);
PlatformMiddlewaresChain = tslib_1.__decorate([
    (0, di_1.Injectable)()
], PlatformMiddlewaresChain);
exports.PlatformMiddlewaresChain = PlatformMiddlewaresChain;
//# sourceMappingURL=PlatformMiddlewaresChain.js.map