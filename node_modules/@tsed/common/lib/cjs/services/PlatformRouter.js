"use strict";
var PlatformRouter_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformRouter = exports.PLATFORM_ROUTER_OPTIONS = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const PlatformHandler_1 = require("./PlatformHandler");
const PlatformAdapter_1 = require("./PlatformAdapter");
/**
 * @ignore
 */
exports.PLATFORM_ROUTER_OPTIONS = Symbol.for("PlatformRouterOptions");
/**
 * Platform Router abstraction layer.
 * @platform
 */
let PlatformRouter = PlatformRouter_1 = class PlatformRouter {
    constructor(platformHandler, adapter, routerOptions = {}) {
        this.platformHandler = platformHandler;
        this.adapter = adapter;
        this.isBuilt = false;
        const { router, callback } = adapter.router(routerOptions);
        this.rawRouter = this.raw = router;
        this.callback = callback;
    }
    /**
     * Create a new instance of PlatformRouter
     * @param injector
     * @param routerOptions
     */
    static create(injector, routerOptions = {}) {
        const locals = new Map();
        locals.set(exports.PLATFORM_ROUTER_OPTIONS, routerOptions);
        return injector.invoke(PlatformRouter_1, locals);
    }
    getRouter() {
        return this.rawRouter;
    }
    use(...handlers) {
        // @ts-ignore
        this.getRouter().use(...this.mapHandlers(handlers));
        return this;
    }
    addRoute(options) {
        const { method, path, handlers, ...opts } = options;
        // @ts-ignore
        this.getRouter()[method](path, ...this.mapHandlers(handlers, { method, path, ...opts }));
        return this;
    }
    all(path, ...handlers) {
        return this.addRoute({ method: "all", path, handlers, isFinal: true });
    }
    get(path, ...handlers) {
        return this.addRoute({ method: "get", path, handlers, isFinal: true });
    }
    post(path, ...handlers) {
        return this.addRoute({ method: "post", path, handlers, isFinal: true });
    }
    put(path, ...handlers) {
        return this.addRoute({ method: "put", path, handlers, isFinal: true });
    }
    delete(path, ...handlers) {
        return this.addRoute({ method: "delete", path, handlers, isFinal: true });
    }
    patch(path, ...handlers) {
        return this.addRoute({ method: "patch", path, handlers, isFinal: true });
    }
    head(path, ...handlers) {
        return this.addRoute({ method: "head", path, handlers, isFinal: true });
    }
    options(path, ...handlers) {
        return this.addRoute({ method: "options", path, handlers, isFinal: true });
    }
    statics(path, options) {
        return this.use(path, this.adapter.statics(path, options));
    }
    multer(options) {
        return this.adapter.multipart(options);
    }
    mapHandlers(handlers, options = {}) {
        return handlers.reduce((list, handler, index) => {
            if (typeof handler === "string") {
                return list.concat(handler);
            }
            if (handler instanceof PlatformRouter_1) {
                return list.concat(handler.callback());
            }
            return list.concat(this.platformHandler.createHandler(handler, {
                ...options,
                isFinal: options.isFinal ? index === handlers.length - 1 : false
            }));
        }, []);
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformRouter.prototype, "injector", void 0);
PlatformRouter = PlatformRouter_1 = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.INSTANCE
    }),
    tslib_1.__param(2, (0, di_1.Inject)(exports.PLATFORM_ROUTER_OPTIONS)),
    tslib_1.__metadata("design:paramtypes", [PlatformHandler_1.PlatformHandler,
        PlatformAdapter_1.PlatformAdapter, Object])
], PlatformRouter);
exports.PlatformRouter = PlatformRouter;
//# sourceMappingURL=PlatformRouter.js.map