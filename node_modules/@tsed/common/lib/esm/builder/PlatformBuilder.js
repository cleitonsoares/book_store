var _PlatformBuilder_injector, _PlatformBuilder_rootModule, _PlatformBuilder_adapter, _PlatformBuilder_promise, _PlatformBuilder_servers, _PlatformBuilder_listeners;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { nameOf } from "@tsed/core";
import { colors, setLoggerLevel } from "@tsed/di";
import { getMiddlewaresForHook } from "@tsed/platform-middlewares";
import { Platform } from "../services/Platform.js";
import { PlatformApplication } from "../services/PlatformApplication.js";
import { getStaticsOptions } from "../utils/getStaticsOptions.js";
import { getConfiguration } from "../utils/getConfiguration.js";
import { PlatformAdapter } from "../services/PlatformAdapter.js";
import { createInjector } from "../utils/createInjector.js";
import { GlobalAcceptMimesMiddleware } from "../middlewares/GlobalAcceptMimesMiddleware.js";
import { printRoutes } from "../utils/printRoutes.js";
import { createHttpServer } from "../utils/createHttpServer.js";
import { createHttpsServer } from "../utils/createHttpsServer.js";
/**
 * @platform
 */
export class PlatformBuilder {
    constructor(adapter, module, settings) {
        this.name = "";
        this.startedAt = new Date();
        this.current = new Date();
        _PlatformBuilder_injector.set(this, void 0);
        _PlatformBuilder_rootModule.set(this, void 0);
        _PlatformBuilder_adapter.set(this, void 0);
        _PlatformBuilder_promise.set(this, void 0);
        _PlatformBuilder_servers.set(this, void 0);
        _PlatformBuilder_listeners.set(this, []);
        __classPrivateFieldSet(this, _PlatformBuilder_rootModule, module, "f");
        const configuration = getConfiguration(settings, module);
        const adapterKlass = adapter || PlatformBuilder.adapter;
        const name = nameOf(adapterKlass).replace("Platform", "").toLowerCase();
        configuration.PLATFORM_NAME = name;
        this.name = name;
        __classPrivateFieldSet(this, _PlatformBuilder_injector, createInjector({
            adapter: adapterKlass,
            settings: configuration
        }), "f");
        __classPrivateFieldSet(this, _PlatformBuilder_adapter, __classPrivateFieldGet(this, _PlatformBuilder_injector, "f").get(PlatformAdapter), "f");
        this.createHttpServers();
        __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").onInit && __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").onInit();
        this.log("Injector created...");
    }
    get injector() {
        return __classPrivateFieldGet(this, _PlatformBuilder_injector, "f");
    }
    get rootModule() {
        return __classPrivateFieldGet(this, _PlatformBuilder_injector, "f").get(__classPrivateFieldGet(this, _PlatformBuilder_rootModule, "f"));
    }
    get app() {
        return this.injector.get(PlatformApplication);
    }
    get platform() {
        return this.injector.get(Platform);
    }
    get adapter() {
        return __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f");
    }
    /**
     * Return the settings configured by the decorator @@Configuration@@.
     *
     * ```typescript
     * @Configuration({
     *    rootDir: Path.resolve(__dirname),
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {PlatformConfiguration}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    get disableBootstrapLog() {
        var _a;
        return (_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.disableBootstrapLog;
    }
    static create(module, settings) {
        return this.build(module, {
            httpsPort: false,
            httpPort: false,
            ...settings,
            disableComponentsScan: true
        });
    }
    static build(module, { adapter, ...settings }) {
        return new PlatformBuilder(adapter, module, settings);
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static async bootstrap(module, settings) {
        const configuration = getConfiguration(settings, module);
        const disableComponentsScan = configuration.disableComponentsScan || !!process.env.WEBPACK;
        if (!disableComponentsScan) {
            const { importProviders } = await import("@tsed/components-scan");
            await importProviders(configuration);
        }
        return this.build(module, configuration).bootstrap();
    }
    callback(req, res) {
        if (req && res) {
            return this.app.callback()(req, res);
        }
        return this.app.callback();
    }
    log(...data) {
        return !this.disableBootstrapLog && this.logger.info(...data, this.diff());
    }
    /**
     * Add classes to the components list
     * @param classes
     * @deprecated
     */
    addComponents(classes) {
        this.settings.componentsScan = this.settings.componentsScan.concat(classes);
        return this;
    }
    /**
     * Add classes decorated by @@Controller@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * platform.addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     */
    addControllers(endpoint, controllers) {
        [].concat(controllers).forEach((token) => {
            this.settings.routes.push({ token, route: endpoint });
        });
    }
    async runLifecycle() {
        setLoggerLevel(this.injector);
        await this.loadInjector();
        __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useContext && __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useContext();
        __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useRouter && __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").useRouter();
        await this.loadRoutes();
        await this.logRoutes();
        return this;
    }
    async loadInjector() {
        const { injector } = this;
        this.log("Build providers");
        await injector.loadModule(__classPrivateFieldGet(this, _PlatformBuilder_rootModule, "f"));
        this.log("Settings and injector loaded...");
        await this.callHook("$afterInit");
    }
    async listen(network = true) {
        if (!__classPrivateFieldGet(this, _PlatformBuilder_promise, "f")) {
            await this.bootstrap();
        }
        await this.callHook("$beforeListen");
        if (network) {
            await this.listenServers();
        }
        await this.callHook("$afterListen");
        await this.ready();
    }
    async stop() {
        await this.callHook("$onDestroy");
        await this.injector.destroy();
        __classPrivateFieldGet(this, _PlatformBuilder_listeners, "f").map((server) => {
            return new Promise((resolve) => server.close(() => resolve(undefined)));
        });
    }
    async ready() {
        const { startedAt } = this;
        await this.callHook("$onReady");
        await this.injector.emit("$onServerReady");
        this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
    }
    async callHook(hook, ...args) {
        const { injector } = this;
        if (!this.disableBootstrapLog) {
            injector.logger.debug(`\x1B[1mCall hook ${hook}\x1B[22m`);
        }
        // Load middlewares for the given hook
        this.loadMiddlewaresFor(hook);
        // call hooks added by providers
        await injector.emit(hook, ...args);
    }
    async loadStatics(hook) {
        const statics = this.settings.get("statics");
        getStaticsOptions(statics).forEach(({ path, options }) => {
            if (options.hook === hook) {
                this.platform.app.statics(path, options);
            }
        });
    }
    useProvider(token, settings) {
        this.injector.addProvider(token, settings);
        return this;
    }
    async bootstrap() {
        __classPrivateFieldSet(this, _PlatformBuilder_promise, __classPrivateFieldGet(this, _PlatformBuilder_promise, "f") || this.runLifecycle(), "f");
        return __classPrivateFieldGet(this, _PlatformBuilder_promise, "f");
    }
    async loadRoutes() {
        var _a, _b;
        __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").beforeLoadRoutes && (await __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").beforeLoadRoutes());
        // istanbul ignore next
        if (((_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.level) !== "off") {
            const { PlatformLogMiddleware } = await import("@tsed/platform-log-middleware");
            this.app.use(PlatformLogMiddleware);
        }
        if ((_b = this.settings.acceptMimes) === null || _b === void 0 ? void 0 : _b.length) {
            this.app.use(GlobalAcceptMimesMiddleware);
        }
        this.log("Load routes");
        if (this.rootModule.$beforeRoutesInit) {
            await this.rootModule.$beforeRoutesInit();
            this.rootModule.$beforeRoutesInit = () => { };
        }
        await this.loadStatics("$beforeRoutesInit");
        await this.callHook("$beforeRoutesInit");
        const routes = this.injector.settings.get("routes");
        this.platform.addRoutes(routes);
        await this.callHook("$onRoutesInit");
        await this.loadStatics("$afterRoutesInit");
        await this.callHook("$afterRoutesInit");
        __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").afterLoadRoutes && (await __classPrivateFieldGet(this, _PlatformBuilder_adapter, "f").afterLoadRoutes());
    }
    diff() {
        const ms = colors.yellow(`+${new Date().getTime() - this.current.getTime()}ms`);
        this.current = new Date();
        return ms;
    }
    /**
     * Load middlewares from configuration for the given hook
     * @param hook
     * @protected
     */
    loadMiddlewaresFor(hook) {
        return getMiddlewaresForHook(hook, this.settings, "$beforeRoutesInit").forEach(({ use }) => {
            this.app.use(use);
        });
    }
    createHttpServers() {
        __classPrivateFieldSet(this, _PlatformBuilder_servers, [createHttpServer(__classPrivateFieldGet(this, _PlatformBuilder_injector, "f"), this.callback()), createHttpsServer(__classPrivateFieldGet(this, _PlatformBuilder_injector, "f"), this.callback())].filter(Boolean), "f");
    }
    async listenServers() {
        __classPrivateFieldSet(this, _PlatformBuilder_listeners, await Promise.all(__classPrivateFieldGet(this, _PlatformBuilder_servers, "f").map((cb) => cb && cb())), "f");
    }
    async logRoutes() {
        var _a;
        const { logger, platform } = this;
        this.log("Routes mounted...");
        if (!((_a = this.settings.logger) === null || _a === void 0 ? void 0 : _a.disableRoutesSummary) && !this.disableBootstrapLog) {
            logger.info(printRoutes(await this.injector.alterAsync("$logRoutes", platform.getRoutes())));
        }
    }
}
_PlatformBuilder_injector = new WeakMap(), _PlatformBuilder_rootModule = new WeakMap(), _PlatformBuilder_adapter = new WeakMap(), _PlatformBuilder_promise = new WeakMap(), _PlatformBuilder_servers = new WeakMap(), _PlatformBuilder_listeners = new WeakMap();
//# sourceMappingURL=PlatformBuilder.js.map