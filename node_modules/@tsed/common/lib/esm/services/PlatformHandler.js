import { __decorate, __metadata } from "tslib";
import { AnyToPromiseStatus, isFunction, isStream } from "@tsed/core";
import { Inject, Injectable, InjectorService, ProviderScope, runInContext } from "@tsed/di";
import { $log } from "@tsed/logger";
import { PlatformParams } from "@tsed/platform-params";
import { PlatformResponseFilter } from "@tsed/platform-response-filter";
import { AnyToPromiseWithCtx } from "../domain/AnyToPromiseWithCtx.js";
import { HandlerMetadata } from "../domain/HandlerMetadata.js";
import { HandlerType } from "../interfaces/HandlerType.js";
import { createHandlerMetadata } from "../utils/createHandlerMetadata.js";
import { setResponseHeaders } from "../utils/setResponseHeaders.js";
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    constructor(injector, params) {
        this.injector = injector;
        this.params = params;
    }
    /**
     * Create a native middleware based on the given metadata and return an instance of AnyToPromiseWithCtx
     * @param input
     * @param options
     */
    createHandler(input, options = {}) {
        return this.createRawHandler(createHandlerMetadata(this.injector, input, options));
    }
    /**
     * Create injectable handler from the given provider
     * @param provider
     * @param propertyKey
     */
    createCustomHandler(provider, propertyKey) {
        const handler = this.compileHandler(new HandlerMetadata({
            token: provider.provide,
            target: provider.useClass,
            type: HandlerType.CUSTOM,
            scope: provider.scope,
            propertyKey
        }));
        return async ($ctx, next) => handler({
            $ctx,
            next
        });
    }
    /**
     * Send the response to the consumer.
     * @param data
     * @param ctx
     * @protected
     */
    async flush(data, ctx) {
        const { response } = ctx;
        if (!response.isDone()) {
            data = await this.responseFilter.serialize(data, ctx);
            data = await this.responseFilter.transform(data, ctx);
            response.body(data);
        }
    }
    compileHandler(metadata) {
        if (metadata.type === HandlerType.CTX_FN) {
            return async (scope) => {
                // @ts-ignore
                return this.onCtxRequest({
                    ...scope,
                    handler: () => metadata.handler(scope.$ctx),
                    metadata
                });
            };
        }
        const promise = this.params.compileHandler({
            token: metadata.token,
            propertyKey: metadata.propertyKey,
            getCustomArgs: metadata.injectable ? undefined : this.getDefaultArgs(metadata)
        });
        return async (scope) => {
            const handler = await promise;
            // @ts-ignore
            return this.onRequest({
                ...scope,
                handler,
                metadata
            });
        };
    }
    async onCtxRequest(requestOptions) {
        await requestOptions.handler(requestOptions);
        return this.next(requestOptions);
    }
    /**
     * Call handler when a request his handle
     * @param requestOptions
     */
    async onRequest(requestOptions) {
        const { $ctx, metadata, err, handler } = requestOptions;
        // istanbul ignore next
        if (!$ctx || $ctx.isDone()) {
            $log.error({
                name: "HEADERS_SENT",
                message: `An endpoint is called but the response is already send to the client. The call comes from the handler: ${metadata.toString()}`
            });
            return;
        }
        const resolver = new AnyToPromiseWithCtx({ $ctx, err });
        return runInContext($ctx, async () => {
            try {
                const { state, data, status, headers } = await resolver.call(handler);
                if (state === AnyToPromiseStatus.RESOLVED) {
                    if (status) {
                        $ctx.response.status(status);
                    }
                    if (headers) {
                        $ctx.response.setHeaders(headers);
                    }
                    if (data !== undefined) {
                        $ctx.data = data;
                    }
                    // Can be canceled by the handler itself
                    return await this.onSuccess($ctx.data, requestOptions);
                }
            }
            catch (er) {
                return this.onError(er, requestOptions);
            }
        });
    }
    async onError(er, requestOptions) {
        const { next, $ctx, metadata } = requestOptions;
        if ($ctx) {
            $ctx.data = er;
        }
        if (!next) {
            throw er;
        }
        // istanbul ignore next
        if (!$ctx || $ctx.isDone()) {
            $log.warn({
                name: "HEADERS_SENT",
                message: `An error was caught after the headers were sent to the client. The error comes from the handler: ${metadata.toString()}`,
                stack: er.stack,
                origin: er,
                request_id: $ctx === null || $ctx === void 0 ? void 0 : $ctx.id
            });
            return;
        }
        return next(er);
    }
    /**
     * Manage success scenario
     * @param data
     * @param requestOptions
     * @protected
     */
    async onSuccess(data, requestOptions) {
        const { metadata, $ctx, next } = requestOptions;
        // istanbul ignore next
        if ($ctx === null || $ctx === void 0 ? void 0 : $ctx.isDone()) {
            return;
        }
        // set headers each times that an endpoint is called
        if (metadata.type === HandlerType.ENDPOINT) {
            this.setHeaders($ctx);
        }
        // call returned middleware
        if (isFunction(data) && !isStream(data)) {
            return this.callReturnedMiddleware(data, $ctx, next);
        }
        if (metadata.isFinal()) {
            return this.flush(data, $ctx);
        }
        return this.next(requestOptions);
    }
    /**
     * Call the returned middleware by the handler.
     * @param middleware
     * @param ctx
     * @param next
     * @protected
     */
    callReturnedMiddleware(middleware, ctx, next) {
        return middleware(ctx.getRequest(), ctx.getResponse(), next);
    }
    /**
     * create Raw handler
     * @param metadata
     */
    createRawHandler(metadata) {
        if ([HandlerType.RAW_ERR_FN, HandlerType.RAW_FN].includes(metadata.type)) {
            return metadata.handler;
        }
        const handler = this.compileHandler(metadata);
        return async (request, response, next) => {
            return handler({
                next,
                $ctx: request.$ctx
            });
        };
    }
    /**
     * Set response headers
     * @param ctx
     * @protected
     */
    setHeaders(ctx) {
        return setResponseHeaders(ctx);
    }
    next(requestOptions) {
        const { $ctx, next } = requestOptions;
        return !$ctx.response.isDone() && next && next();
    }
    getDefaultArgs(metadata) {
        return async (scope) => [
            metadata.hasErrorParam && scope.err,
            scope.$ctx.request.request,
            scope.$ctx.response.response,
            metadata.hasNextFunction && scope.next
        ].filter(Boolean);
    }
};
__decorate([
    Inject(),
    __metadata("design:type", PlatformResponseFilter)
], PlatformHandler.prototype, "responseFilter", void 0);
PlatformHandler = __decorate([
    Injectable({
        scope: ProviderScope.SINGLETON
    }),
    __metadata("design:paramtypes", [InjectorService, PlatformParams])
], PlatformHandler);
export { PlatformHandler };
//# sourceMappingURL=PlatformHandler.js.map