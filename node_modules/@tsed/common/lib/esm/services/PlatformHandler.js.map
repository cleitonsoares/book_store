{"version":3,"file":"PlatformHandler.js","sourceRoot":"","sources":["../../../src/services/PlatformHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import {AnyToPromiseStatus, isFunction, isStream} from \"@tsed/core\";\nimport {Inject, Injectable, InjectorService, Provider, ProviderScope, runInContext} from \"@tsed/di\";\nimport {$log} from \"@tsed/logger\";\nimport {ArgScope, HandlerWithScope, PlatformParams} from \"@tsed/platform-params\";\nimport {PlatformResponseFilter} from \"@tsed/platform-response-filter\";\nimport {EndpointMetadata} from \"@tsed/schema\";\nimport {AnyToPromiseWithCtx} from \"../domain/AnyToPromiseWithCtx\";\nimport {HandlerMetadata} from \"../domain/HandlerMetadata\";\nimport {PlatformContext} from \"../domain/PlatformContext\";\nimport {HandlerType} from \"../interfaces/HandlerType\";\nimport {PlatformRouteWithoutHandlers} from \"../interfaces/PlatformRouteOptions\";\nimport {createHandlerMetadata} from \"../utils/createHandlerMetadata\";\nimport {setResponseHeaders} from \"../utils/setResponseHeaders\";\n\nexport interface OnRequestOptions {\n  $ctx: PlatformContext;\n  metadata: HandlerMetadata;\n  handler: HandlerWithScope;\n  next?: any;\n  err?: any;\n\n  [key: string]: any;\n}\n\n/**\n * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).\n * @platform\n */\n@Injectable({\n  scope: ProviderScope.SINGLETON\n})\nexport class PlatformHandler {\n  @Inject()\n  protected responseFilter: PlatformResponseFilter;\n\n  constructor(protected injector: InjectorService, protected params: PlatformParams) {}\n\n  /**\n   * Create a native middleware based on the given metadata and return an instance of AnyToPromiseWithCtx\n   * @param input\n   * @param options\n   */\n  createHandler(input: EndpointMetadata | HandlerMetadata | any, options: PlatformRouteWithoutHandlers = {}) {\n    return this.createRawHandler(createHandlerMetadata(this.injector, input, options));\n  }\n\n  /**\n   * Create injectable handler from the given provider\n   * @param provider\n   * @param propertyKey\n   */\n  createCustomHandler(provider: Provider, propertyKey: string) {\n    const handler = this.compileHandler(\n      new HandlerMetadata({\n        token: provider.provide,\n        target: provider.useClass,\n        type: HandlerType.CUSTOM,\n        scope: provider.scope,\n        propertyKey\n      })\n    );\n\n    return async ($ctx: PlatformContext, next?: any) =>\n      handler({\n        $ctx,\n        next\n      });\n  }\n\n  /**\n   * Send the response to the consumer.\n   * @param data\n   * @param ctx\n   * @protected\n   */\n  async flush(data: any, ctx: PlatformContext) {\n    const {response} = ctx;\n\n    if (!response.isDone()) {\n      data = await this.responseFilter.serialize(data, ctx);\n      data = await this.responseFilter.transform(data, ctx);\n      response.body(data);\n    }\n  }\n\n  compileHandler(metadata: HandlerMetadata) {\n    if (metadata.type === HandlerType.CTX_FN) {\n      return async (scope: Record<string, any>) => {\n        // @ts-ignore\n        return this.onCtxRequest({\n          ...scope,\n          handler: () => metadata.handler(scope.$ctx),\n          metadata\n        });\n      };\n    }\n\n    const promise = this.params.compileHandler<PlatformContext>({\n      token: metadata.token,\n      propertyKey: metadata.propertyKey,\n      getCustomArgs: metadata.injectable ? undefined : this.getDefaultArgs(metadata)\n    });\n\n    return async (scope: Record<string, any>) => {\n      const handler = await promise;\n      // @ts-ignore\n      return this.onRequest({\n        ...scope,\n        handler,\n        metadata\n      });\n    };\n  }\n\n  protected async onCtxRequest(requestOptions: OnRequestOptions): Promise<any> {\n    await requestOptions.handler(requestOptions);\n\n    return this.next(requestOptions);\n  }\n\n  /**\n   * Call handler when a request his handle\n   * @param requestOptions\n   */\n  protected async onRequest(requestOptions: OnRequestOptions): Promise<any> {\n    const {$ctx, metadata, err, handler} = requestOptions;\n    // istanbul ignore next\n    if (!$ctx || $ctx.isDone()) {\n      $log.error({\n        name: \"HEADERS_SENT\",\n        message: `An endpoint is called but the response is already send to the client. The call comes from the handler: ${metadata.toString()}`\n      });\n      return;\n    }\n\n    const resolver = new AnyToPromiseWithCtx({$ctx, err});\n\n    return runInContext($ctx, async () => {\n      try {\n        const {state, data, status, headers} = await resolver.call(handler);\n\n        if (state === AnyToPromiseStatus.RESOLVED) {\n          if (status) {\n            $ctx.response.status(status);\n          }\n\n          if (headers) {\n            $ctx.response.setHeaders(headers);\n          }\n\n          if (data !== undefined) {\n            $ctx.data = data;\n          }\n\n          // Can be canceled by the handler itself\n          return await this.onSuccess($ctx.data, requestOptions);\n        }\n      } catch (er) {\n        return this.onError(er, requestOptions);\n      }\n    });\n  }\n\n  protected async onError(er: Error, requestOptions: OnRequestOptions) {\n    const {next, $ctx, metadata} = requestOptions;\n\n    if ($ctx) {\n      $ctx.data = er;\n    }\n\n    if (!next) {\n      throw er;\n    }\n\n    // istanbul ignore next\n    if (!$ctx || $ctx.isDone()) {\n      $log.warn({\n        name: \"HEADERS_SENT\",\n        message: `An error was caught after the headers were sent to the client. The error comes from the handler: ${metadata.toString()}`,\n        stack: er.stack,\n        origin: er,\n        request_id: $ctx?.id\n      });\n\n      return;\n    }\n\n    return next(er);\n  }\n\n  /**\n   * Manage success scenario\n   * @param data\n   * @param requestOptions\n   * @protected\n   */\n  protected async onSuccess(data: any, requestOptions: OnRequestOptions) {\n    const {metadata, $ctx, next} = requestOptions;\n\n    // istanbul ignore next\n    if ($ctx?.isDone()) {\n      return;\n    }\n\n    // set headers each times that an endpoint is called\n    if (metadata.type === HandlerType.ENDPOINT) {\n      this.setHeaders($ctx);\n    }\n\n    // call returned middleware\n    if (isFunction(data) && !isStream(data)) {\n      return this.callReturnedMiddleware(data, $ctx, next);\n    }\n\n    if (metadata.isFinal()) {\n      return this.flush(data, $ctx);\n    }\n\n    return this.next(requestOptions);\n  }\n\n  /**\n   * Call the returned middleware by the handler.\n   * @param middleware\n   * @param ctx\n   * @param next\n   * @protected\n   */\n  protected callReturnedMiddleware(middleware: any, ctx: PlatformContext, next: any) {\n    return middleware(ctx.getRequest(), ctx.getResponse(), next);\n  }\n\n  /**\n   * create Raw handler\n   * @param metadata\n   */\n  protected createRawHandler(metadata: HandlerMetadata) {\n    if ([HandlerType.RAW_ERR_FN, HandlerType.RAW_FN].includes(metadata.type)) {\n      return metadata.handler;\n    }\n\n    const handler = this.compileHandler(metadata);\n\n    return async (request: any, response: any, next: any) => {\n      return handler({\n        next,\n        $ctx: request.$ctx\n      });\n    };\n  }\n\n  /**\n   * Set response headers\n   * @param ctx\n   * @protected\n   */\n  protected setHeaders(ctx: PlatformContext) {\n    return setResponseHeaders(ctx);\n  }\n\n  protected next(requestOptions: OnRequestOptions) {\n    const {$ctx, next} = requestOptions;\n\n    return !$ctx.response.isDone() && next && next();\n  }\n\n  protected getDefaultArgs(metadata: HandlerMetadata) {\n    return async (scope: ArgScope<PlatformContext>) =>\n      [\n        metadata.hasErrorParam && scope.err,\n        scope.$ctx.request.request,\n        scope.$ctx.response.response,\n        metadata.hasNextFunction && scope.next\n      ].filter(Boolean);\n  }\n}\n"]}