"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectContext = exports.Inject = exports.injectProperty = void 0;
const core_1 = require("@tsed/core");
const constants_1 = require("../constants/constants");
const runInContext_1 = require("../utils/runInContext");
function injectProperty(target, propertyKey, options) {
    core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
        [propertyKey]: {
            bindingType: core_1.DecoratorTypes.PROP,
            propertyKey,
            ...options
        }
    });
}
exports.injectProperty = injectProperty;
/**
 * Inject a provider to another provider.
 *
 * Use this decorator to inject a custom provider on constructor parameter or property.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @Inject(CONNECTION)
 *   connection: CONNECTION;
 * }
 * ```
 *
 * @param symbol
 * @param onGet Use the given name method to inject
 * @returns {Function}
 * @decorator
 */
function Inject(symbol, onGet = (bean) => bean) {
    return (target, propertyKey, descriptor) => {
        const bindingType = (0, core_1.decoratorTypeOf)([target, propertyKey, descriptor]);
        switch (bindingType) {
            case core_1.DecoratorTypes.PARAM:
            case core_1.DecoratorTypes.PARAM_CTOR:
                if (symbol) {
                    const paramTypes = core_1.Metadata.getParamTypes(target, propertyKey);
                    paramTypes[descriptor] = symbol;
                    core_1.Metadata.setParamTypes(target, propertyKey, paramTypes);
                }
                break;
            case core_1.DecoratorTypes.PROP:
                injectProperty(target, propertyKey, {
                    resolver(injector, locals, { options, ...invokeOptions }) {
                        locals.set(constants_1.DI_PARAM_OPTIONS, { ...options });
                        let bean;
                        if (!bean) {
                            const useType = symbol || core_1.Metadata.getType(target, propertyKey);
                            bean = injector.invoke(useType, locals, invokeOptions);
                            locals.delete(constants_1.DI_PARAM_OPTIONS);
                        }
                        if ((0, core_1.isPromise)(bean)) {
                            bean.then((result) => {
                                bean = result;
                            });
                        }
                        return () => onGet(bean);
                    }
                });
                break;
            case core_1.DecoratorTypes.METHOD:
                core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
                    [propertyKey]: {
                        bindingType,
                        propertyKey
                    }
                });
                return descriptor;
            default:
                throw new core_1.UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);
        }
    };
}
exports.Inject = Inject;
/**
 * Inject a context like PlatformContext or any BaseContext.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @InjectContext()
 *   ctx?: Context;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 */
function InjectContext() {
    return (target, propertyKey) => {
        injectProperty(target, propertyKey, {
            resolver() {
                return () => (0, runInContext_1.getContext)();
            }
        });
    };
}
exports.InjectContext = InjectContext;
//# sourceMappingURL=inject.js.map