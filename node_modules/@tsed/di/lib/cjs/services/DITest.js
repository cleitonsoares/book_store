"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DITest = void 0;
const core_1 = require("@tsed/core");
const logger_1 = require("@tsed/logger");
const createContainer_1 = require("../utils/createContainer");
const LocalsContainer_1 = require("../domain/LocalsContainer");
const setLoggerLevel_1 = require("../utils/setLoggerLevel");
const InjectorService_1 = require("./InjectorService");
const DIContext_1 = require("../domain/DIContext");
/**
 * Tool to run test with lightweight DI sandbox.
 */
class DITest {
    static get injector() {
        if (DITest._injector) {
            return DITest._injector;
        }
        /* istanbul ignore next */
        throw new Error("PlatformTest.injector is not initialized. Use PlatformTest.create(): Promise before PlatformTest.invoke() or PlatformTest.injector.\n" +
            "Example:\n" +
            "before(async () => {\n" +
            "   await PlatformTest.create()\n" +
            "   await PlatformTest.invoke(MyService, [])\n" +
            "})");
    }
    static set injector(injector) {
        DITest._injector = injector;
    }
    static hasInjector() {
        return !!DITest._injector;
    }
    static async create(settings = {}) {
        DITest.injector = DITest.createInjector(settings);
        await this.createContainer(settings);
    }
    static async createContainer(settings = {}) {
        var _a;
        const container = (0, createContainer_1.createContainer)();
        (_a = settings.imports) === null || _a === void 0 ? void 0 : _a.forEach(({ token, use }) => {
            container.addProvider(token, {
                useValue: use
            });
        });
        await DITest.injector.load(container);
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        const injector = new InjectorService_1.InjectorService();
        injector.logger = logger_1.$log;
        // @ts-ignore
        injector.settings.set(DITest.configure(settings));
        (0, setLoggerLevel_1.setLoggerLevel)(injector);
        return injector;
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static async reset() {
        if (DITest.hasInjector()) {
            await DITest.injector.destroy();
            DITest._injector = null;
        }
    }
    /**
     * Invoke a provider and return a fresh instance
     * @param target
     * @param providers
     */
    static invoke(target, providers = []) {
        const locals = new LocalsContainer_1.LocalsContainer();
        providers.forEach((p) => {
            locals.set(p.token, p.use);
        });
        locals.set(InjectorService_1.InjectorService, DITest.injector);
        const instance = DITest.injector.invoke(target, locals, { rebuild: true });
        if (instance && instance.$onInit) {
            // await instance.$onInit();
            const result = instance.$onInit();
            if (result instanceof Promise) {
                return result.then(() => instance);
            }
        }
        return instance;
    }
    /**
     * Return the instance from injector registry
     * @param target
     * @param options
     */
    static get(target, options = {}) {
        return DITest.injector.get(target, options);
    }
    static createDIContext() {
        return new DIContext_1.DIContext({
            id: "id",
            injector: DITest.injector,
            logger: DITest.injector.logger
        });
    }
    static configure(settings = {}) {
        return {
            ...settings,
            env: (0, core_1.getValue)(settings, "env", core_1.Env.TEST),
            logger: {
                ...(0, core_1.getValue)(settings, "logger", {}),
                level: (0, core_1.getValue)(settings, "logger.level", "off")
            }
        };
    }
}
exports.DITest = DITest;
DITest._injector = null;
//# sourceMappingURL=DITest.js.map