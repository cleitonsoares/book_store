"use strict";
var _InjectorService_cache;
var InjectorService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectorService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const constants_1 = require("../constants/constants");
const configuration_1 = require("../decorators/configuration");
const injectable_1 = require("../decorators/injectable");
const Container_1 = require("../domain/Container");
const LocalsContainer_1 = require("../domain/LocalsContainer");
const Provider_1 = require("../domain/Provider");
const InjectionError_1 = require("../errors/InjectionError");
const UndefinedTokenError_1 = require("../errors/UndefinedTokenError");
const GlobalProviders_1 = require("../registries/GlobalProviders");
const createContainer_1 = require("../utils/createContainer");
const DIConfiguration_1 = require("./DIConfiguration");
const ProviderScope_1 = require("../domain/ProviderScope");
const InjectablePropertyType_1 = require("../domain/InjectablePropertyType");
const runInContext_1 = require("../utils/runInContext");
const resolveControllers_1 = require("../utils/resolveControllers");
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/di";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 *
 * await injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 */
let InjectorService = InjectorService_1 = class InjectorService extends Container_1.Container {
    constructor() {
        super();
        this.settings = new DIConfiguration_1.DIConfiguration();
        this.logger = console;
        this.runInContext = runInContext_1.runInContext;
        this.resolvedConfiguration = false;
        _InjectorService_cache.set(this, new LocalsContainer_1.LocalsContainer());
        tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").set(InjectorService_1, this);
    }
    get resolvers() {
        return this.settings.resolvers;
    }
    get scopes() {
        return this.settings.scopes || {};
    }
    /**
     * Retrieve default scope for a given provider.
     * @param provider
     */
    scopeOf(provider) {
        return provider.scope || this.scopes[provider.type] || ProviderScope_1.ProviderScope.SINGLETON;
    }
    /**
     * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.
     * @param token
     * @param settings
     * @deprecated
     */
    forkProvider(token, settings = {}) {
        if (!this.hasProvider(token)) {
            this.addProvider(token);
        }
        const provider = this.getProvider(token);
        Object.assign(provider, settings);
        tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").set(token, this.invoke(token));
        return provider;
    }
    /**
     * Return a list of instance build by the injector.
     */
    toArray() {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").toArray();
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param token The class or symbol registered in InjectorService.
     * @param options
     * @returns {boolean}
     */
    get(token, options = {}) {
        const instance = this.getInstance(token);
        if (instance !== undefined) {
            return instance;
        }
        if (!this.hasProvider(token)) {
            for (const resolver of this.resolvers) {
                const result = resolver.get(token, options);
                if (result !== undefined) {
                    return result;
                }
            }
        }
    }
    /**
     * Return all instance of the same provider type
     * @param type
     */
    getAll(type) {
        return this.getProviders(type).map((provider) => {
            return this.get(provider.token);
        });
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @returns {boolean}
     * @param token
     */
    has(token) {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").get(token) !== undefined;
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param options
     * @returns {T} The class constructed.
     */
    invoke(token, locals = new LocalsContainer_1.LocalsContainer(), options = {}) {
        const provider = this.ensureProvider(token);
        let instance;
        !locals.has(configuration_1.Configuration) && locals.set(configuration_1.Configuration, this.settings);
        if (locals.has(token)) {
            return locals.get(token);
        }
        if (token === constants_1.DI_PARAM_OPTIONS) {
            return {};
        }
        if (!provider || options.rebuild) {
            instance = this.resolve(token, locals, options);
            if (this.hasProvider(token)) {
                tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").set(token, instance);
            }
            return instance;
        }
        switch (this.scopeOf(provider)) {
            case ProviderScope_1.ProviderScope.SINGLETON:
                if (!this.has(token)) {
                    tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").set(token, this.resolve(token, locals, options));
                    if (provider.isAsync()) {
                        tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").get(token).then((instance) => {
                            tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").set(token, instance);
                        });
                    }
                }
                instance = this.get(token);
                break;
            case ProviderScope_1.ProviderScope.REQUEST:
                instance = this.resolve(token, locals, options);
                locals.set(token, instance);
                break;
            case ProviderScope_1.ProviderScope.INSTANCE:
                instance = this.resolve(provider.provide, locals, options);
                break;
        }
        return instance;
    }
    /**
     * Build only providers which are asynchronous.
     */
    async loadAsync(locals = new LocalsContainer_1.LocalsContainer()) {
        for (const [, provider] of this) {
            if (!locals.has(provider.token)) {
                if (provider.isAsync()) {
                    await this.invoke(provider.token, locals);
                }
                const instance = tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").get(provider.token);
                if (instance !== undefined) {
                    locals.set(provider.token, instance);
                }
            }
        }
        return locals;
    }
    loadSync(locals = new LocalsContainer_1.LocalsContainer()) {
        for (const [, provider] of this) {
            if (!locals.has(provider.token) && this.scopeOf(provider) === ProviderScope_1.ProviderScope.SINGLETON) {
                this.invoke(provider.token, locals);
            }
            const instance = tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").get(provider.token);
            if (instance !== undefined) {
                locals.set(provider.token, instance);
            }
        }
        return locals;
    }
    /**
     * Boostrap injector from container and resolve configuration.
     *
     * @param container
     */
    bootstrap(container = (0, createContainer_1.createContainer)()) {
        // Clone all providers in the container
        this.addProviders(container);
        // Resolve all configuration
        this.resolveConfiguration();
        return this;
    }
    /**
     * Load injector from a given module
     * @param rootModule
     */
    loadModule(rootModule) {
        this.settings.routes = this.settings.routes.concat((0, resolveControllers_1.resolveControllers)(this.settings));
        const container = (0, createContainer_1.createContainer)();
        container.delete(rootModule);
        container.addProvider(rootModule, {
            type: "server:module",
            scope: ProviderScope_1.ProviderScope.SINGLETON
        });
        return this.load(container);
    }
    /**
     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.
     *
     * @param container
     * @param rootModule
     */
    async load(container = (0, createContainer_1.createContainer)(), rootModule) {
        this.bootstrap(container);
        // build async and sync provider
        let locals = await this.loadAsync();
        if (rootModule) {
            await this.invoke(rootModule);
        }
        // load sync provider
        locals = this.loadSync(locals);
        await locals.emit("$beforeInit");
        await locals.emit("$onInit");
        return locals;
    }
    /**
     * Load all configurations registered on providers
     */
    resolveConfiguration() {
        if (this.resolvedConfiguration) {
            return;
        }
        const mergedConfiguration = new Map();
        super.forEach((provider) => {
            if (provider.configuration && provider.type !== "server:module") {
                Object.entries(provider.configuration).forEach(([key, value]) => {
                    if (!["resolvers", "mount", "imports"].includes(key)) {
                        value = mergedConfiguration.has(key) ? (0, core_1.deepMerge)(mergedConfiguration.get(key), value) : (0, core_1.deepClone)(value);
                        mergedConfiguration.set(key, value);
                    }
                });
            }
            if (provider.resolvers) {
                this.resolvers.push(...provider.resolvers);
            }
        });
        mergedConfiguration.forEach((value, key) => {
            this.settings[key] = (0, core_1.deepMerge)(value, this.settings[key]);
        });
        this.settings.build();
        this.resolvedConfiguration = true;
    }
    /**
     *
     * @param instance
     * @param locals
     * @param options
     */
    bindInjectableProperties(instance, locals, options) {
        const properties = (0, core_1.ancestorsOf)((0, core_1.classOf)(instance)).reduce((properties, target) => {
            const store = core_1.Store.from(target);
            return {
                ...properties,
                ...(store.get(constants_1.INJECTABLE_PROP) || {})
            };
        }, {});
        Object.values(properties).forEach((definition) => {
            switch (definition.bindingType) {
                case InjectablePropertyType_1.InjectablePropertyType.METHOD:
                    this.bindMethod(instance, definition);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.PROPERTY:
                    this.bindProperty(instance, definition, locals, options);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.CONSTANT:
                    this.bindConstant(instance, definition);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.VALUE:
                    this.bindValue(instance, definition);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.INTERCEPTOR:
                    this.bindInterceptor(instance, definition);
                    break;
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     */
    bindMethod(instance, { propertyKey }) {
        const target = (0, core_1.classOf)(instance);
        const originalMethod = instance[propertyKey];
        const deps = core_1.Metadata.getParamTypes((0, core_1.prototypeOf)(target), propertyKey);
        instance[propertyKey] = () => {
            const services = deps.map((dependency) => this.get(dependency));
            return originalMethod.call(instance, ...services);
        };
    }
    /**
     * Create an injectable property.
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     * @param resolver
     * @param options
     * @param locals
     * @param invokeOptions
     */
    bindProperty(instance, { propertyKey, resolver, options = {} }, locals, invokeOptions) {
        let get;
        get = resolver(this, locals, { ...invokeOptions, options });
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, {
            get
        }));
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance, { propertyKey, expression, defaultValue }) {
        const descriptor = {
            get: () => this.settings.get(expression) || defaultValue,
            set: (value) => this.settings.set(expression, value),
            enumerable: true,
            configurable: true
        };
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, descriptor));
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance, { propertyKey, expression, defaultValue }) {
        let bean;
        const get = () => {
            if (bean !== undefined) {
                return bean;
            }
            const value = this.settings.get(expression, defaultValue);
            bean = Object.freeze((0, core_1.deepClone)(value));
            return bean;
        };
        const descriptor = {
            get,
            enumerable: true,
            configurable: true
        };
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, descriptor));
    }
    /**
     *
     * @param instance
     * @param propertyKey
     * @param useType
     * @param options
     */
    bindInterceptor(instance, { propertyKey, useType, options }) {
        const target = (0, core_1.classOf)(instance);
        const originalMethod = instance[propertyKey];
        instance[propertyKey] = (...args) => {
            const next = (err) => {
                if (!err) {
                    return originalMethod.apply(instance, args);
                }
                throw err;
            };
            const context = {
                target,
                propertyKey,
                args,
                options,
                next
            };
            const interceptor = this.get(useType);
            return interceptor.intercept({
                ...context,
                options
            }, next);
        };
    }
    async lazyInvoke(token) {
        let instance = this.getInstance(token);
        if (!instance) {
            instance = await this.invoke(token);
            if ((0, core_1.isFunction)(instance === null || instance === void 0 ? void 0 : instance.$onInit)) {
                await instance.$onInit();
            }
        }
        return instance;
    }
    /**
     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each services.
     * @returns {Promise<any[]>} A list of promises.
     */
    async emit(eventName, ...args) {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").emit(eventName, ...args);
    }
    /**
     * @param eventName
     * @param value
     * @param args
     */
    alter(eventName, value, ...args) {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").alter(eventName, value, ...args);
    }
    /**
     * @param eventName
     * @param value
     * @param args
     */
    async alterAsync(eventName, value, ...args) {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").alterAsync(eventName, value, ...args);
    }
    async destroy() {
        await tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").destroy();
    }
    ensureProvider(token) {
        if (!this.hasProvider(token) && GlobalProviders_1.GlobalProviders.has(token)) {
            this.addProvider(token);
        }
        return this.getProvider(token);
    }
    getInstance(token) {
        return tslib_1.__classPrivateFieldGet(this, _InjectorService_cache, "f").get(token);
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * @param target
     * @param locals
     * @param options
     * @private
     */
    resolve(target, locals, options = {}) {
        const resolvedOpts = this.mapInvokeOptions(target, locals, options);
        const { token, deps, construct, imports, provider } = resolvedOpts;
        if (provider) {
            GlobalProviders_1.GlobalProviders.onInvoke(provider, locals, { ...resolvedOpts, injector: this });
        }
        let instance;
        let currentDependency = false;
        try {
            const invokeDependency = (parent) => (token, index) => {
                var _a;
                currentDependency = { token, index, deps };
                if (token !== constants_1.DI_PARAM_OPTIONS) {
                    const options = (_a = provider === null || provider === void 0 ? void 0 : provider.store) === null || _a === void 0 ? void 0 : _a.get(`${constants_1.DI_PARAM_OPTIONS}:${index}`);
                    locals.set(constants_1.DI_PARAM_OPTIONS, options || {});
                }
                return (0, core_1.isInheritedFrom)(token, Provider_1.Provider, 1) ? provider : this.invoke(token, locals, { parent });
            };
            // Invoke manually imported providers
            imports.forEach(invokeDependency());
            // Inject dependencies
            const services = deps.map(invokeDependency(token));
            currentDependency = false;
            instance = construct(services);
        }
        catch (error) {
            InjectionError_1.InjectionError.throwInjectorError(token, currentDependency, error);
        }
        if (instance === undefined) {
            throw new InjectionError_1.InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${(0, core_1.nameOf)(token)}`);
        }
        if (instance && (0, core_1.isClass)((0, core_1.classOf)(instance))) {
            this.bindInjectableProperties(instance, locals, options);
        }
        if (instance && provider.hooks) {
            Object.entries(provider.hooks).forEach(([key, cb]) => {
                instance[key] = (...args) => cb(instance, ...args);
            });
        }
        return instance;
    }
    /**
     * Create options to invoke a provider or class.
     * @param token
     * @param locals
     * @param options
     */
    mapInvokeOptions(token, locals, options) {
        let imports = options.imports;
        let deps = options.deps;
        let scope = options.scope;
        let construct;
        if (!token) {
            throw new UndefinedTokenError_1.UndefinedTokenError();
        }
        let provider;
        if (!this.hasProvider(token)) {
            provider = new Provider_1.Provider(token);
            this.resolvers.forEach((resolver) => {
                const result = resolver.get(token, locals.get(constants_1.DI_PARAM_OPTIONS));
                if (result !== undefined) {
                    provider.useFactory = () => result;
                }
            });
        }
        else {
            provider = this.getProvider(token);
        }
        scope = scope || this.scopeOf(provider);
        deps = deps || provider.deps;
        imports = imports || provider.imports;
        if (provider.useValue !== undefined) {
            construct = () => ((0, core_1.isFunction)(provider.useValue) ? provider.useValue() : provider.useValue);
        }
        else if (provider.useFactory) {
            construct = (deps) => provider.useFactory(...deps);
        }
        else if (provider.useAsyncFactory) {
            construct = async (deps) => {
                deps = await Promise.all(deps);
                return provider.useAsyncFactory(...deps);
            };
        }
        else {
            // useClass
            deps = deps || core_1.Metadata.getParamTypes(provider.useClass);
            construct = (deps) => new provider.useClass(...deps);
        }
        return {
            token,
            scope: scope || core_1.Store.from(token).get("scope") || ProviderScope_1.ProviderScope.SINGLETON,
            deps: deps || [],
            imports: imports || [],
            construct,
            provider
        };
    }
};
_InjectorService_cache = new WeakMap();
InjectorService = InjectorService_1 = tslib_1.__decorate([
    (0, injectable_1.Injectable)({
        scope: ProviderScope_1.ProviderScope.SINGLETON,
        global: true
    }),
    tslib_1.__metadata("design:paramtypes", [])
], InjectorService);
exports.InjectorService = InjectorService;
//# sourceMappingURL=InjectorService.js.map