{"version":3,"file":"InjectorService.js","sourceRoot":"","sources":["../../../src/services/InjectorService.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ancestorsOf,\n  catchError,\n  classOf,\n  deepClone,\n  deepMerge,\n  isClass,\n  isFunction,\n  isInheritedFrom,\n  Metadata,\n  nameOf,\n  prototypeOf,\n  Store\n} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants/constants\";\nimport {Configuration} from \"../decorators/configuration\";\nimport {Injectable} from \"../decorators/injectable\";\nimport {Container} from \"../domain/Container\";\nimport {LocalsContainer} from \"../domain/LocalsContainer\";\nimport {Provider} from \"../domain/Provider\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {UndefinedTokenError} from \"../errors/UndefinedTokenError\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\nimport {createContainer} from \"../utils/createContainer\";\nimport {DIConfiguration} from \"./DIConfiguration\";\nimport {ResolvedInvokeOptions} from \"../interfaces/ResolvedInvokeOptions\";\nimport {ProviderScope} from \"../domain/ProviderScope\";\nimport {DILogger} from \"../interfaces/DILogger\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\nimport {ProviderOpts} from \"../interfaces/ProviderOpts\";\nimport {InvokeOptions} from \"../interfaces/InvokeOptions\";\nimport {InjectableProperties, InjectablePropertyOptions, InjectablePropertyValue} from \"../interfaces/InjectableProperties\";\nimport {InjectablePropertyType} from \"../domain/InjectablePropertyType\";\nimport {InterceptorContext} from \"../interfaces/InterceptorContext\";\nimport {InterceptorMethods} from \"../interfaces/InterceptorMethods\";\nimport {runInContext} from \"../utils/runInContext\";\nimport {resolveControllers} from \"../utils/resolveControllers\";\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/di\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n *\n * await injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n */\n@Injectable({\n  scope: ProviderScope.SINGLETON,\n  global: true\n})\nexport class InjectorService extends Container {\n  public settings: TsED.Configuration & DIConfiguration = new DIConfiguration() as any;\n  public logger: DILogger = console;\n  public runInContext = runInContext;\n  private resolvedConfiguration: boolean = false;\n  #cache = new LocalsContainer();\n\n  constructor() {\n    super();\n    this.#cache.set(InjectorService, this);\n  }\n\n  get resolvers() {\n    return this.settings.resolvers!;\n  }\n\n  get scopes() {\n    return this.settings.scopes || {};\n  }\n\n  /**\n   * Retrieve default scope for a given provider.\n   * @param provider\n   */\n  public scopeOf(provider: Provider) {\n    return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n  }\n\n  /**\n   * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.\n   * @param token\n   * @param settings\n   * @deprecated\n   */\n  public forkProvider(token: TokenProvider, settings: Partial<ProviderOpts<any>> = {}): Provider {\n    if (!this.hasProvider(token)) {\n      this.addProvider(token);\n    }\n\n    const provider = this.getProvider(token)!;\n\n    Object.assign(provider, settings);\n\n    this.#cache.set(token, this.invoke(token));\n\n    return provider;\n  }\n\n  /**\n   * Return a list of instance build by the injector.\n   */\n  public toArray(): any[] {\n    return this.#cache.toArray();\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/di\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param token The class or symbol registered in InjectorService.\n   * @param options\n   * @returns {boolean}\n   */\n  get<T = any>(token: TokenProvider, options: any = {}): T | undefined {\n    const instance = this.getInstance(token);\n\n    if (instance !== undefined) {\n      return instance;\n    }\n\n    if (!this.hasProvider(token)) {\n      for (const resolver of this.resolvers) {\n        const result = resolver.get(token, options);\n\n        if (result !== undefined) {\n          return result;\n        }\n      }\n    }\n  }\n\n  /**\n   * Return all instance of the same provider type\n   * @param type\n   */\n  getAll(type: string) {\n    return this.getProviders(type).map((provider) => {\n      return this.get(provider.token);\n    });\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @returns {boolean}\n   * @param token\n   */\n  has(token: TokenProvider): boolean {\n    return this.#cache.get(token) !== undefined;\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/di\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param options\n   * @returns {T} The class constructed.\n   */\n  public invoke<T>(\n    token: TokenProvider,\n    locals: Map<TokenProvider, any> = new LocalsContainer(),\n    options: Partial<InvokeOptions<T>> = {}\n  ): T {\n    const provider = this.ensureProvider(token);\n    let instance: any;\n\n    !locals.has(Configuration) && locals.set(Configuration, this.settings);\n\n    if (locals.has(token)) {\n      return locals.get(token);\n    }\n\n    if (token === DI_PARAM_OPTIONS) {\n      return {} as T;\n    }\n\n    if (!provider || options.rebuild) {\n      instance = this.resolve(token, locals, options);\n\n      if (this.hasProvider(token)) {\n        this.#cache.set(token, instance);\n      }\n\n      return instance;\n    }\n\n    switch (this.scopeOf(provider)) {\n      case ProviderScope.SINGLETON:\n        if (!this.has(token)) {\n          this.#cache.set(token, this.resolve(token, locals, options));\n\n          if (provider.isAsync()) {\n            this.#cache.get(token).then((instance: any) => {\n              this.#cache.set(token, instance);\n            });\n          }\n        }\n\n        instance = this.get<T>(token)!;\n        break;\n\n      case ProviderScope.REQUEST:\n        instance = this.resolve(token, locals, options);\n        locals.set(token, instance);\n        break;\n\n      case ProviderScope.INSTANCE:\n        instance = this.resolve(provider.provide, locals, options);\n        break;\n    }\n\n    return instance;\n  }\n\n  /**\n   * Build only providers which are asynchronous.\n   */\n  async loadAsync(locals: LocalsContainer = new LocalsContainer()) {\n    for (const [, provider] of this) {\n      if (!locals.has(provider.token)) {\n        if (provider.isAsync()) {\n          await this.invoke(provider.token, locals);\n        }\n\n        const instance = this.#cache.get(provider.token);\n        if (instance !== undefined) {\n          locals.set(provider.token, instance);\n        }\n      }\n    }\n\n    return locals;\n  }\n\n  loadSync(locals: LocalsContainer = new LocalsContainer()) {\n    for (const [, provider] of this) {\n      if (!locals.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n        this.invoke(provider.token, locals);\n      }\n\n      const instance = this.#cache.get(provider.token);\n      if (instance !== undefined) {\n        locals.set(provider.token, instance);\n      }\n    }\n\n    return locals;\n  }\n\n  /**\n   * Boostrap injector from container and resolve configuration.\n   *\n   * @param container\n   */\n  bootstrap(container: Container = createContainer()) {\n    // Clone all providers in the container\n    this.addProviders(container);\n\n    // Resolve all configuration\n    this.resolveConfiguration();\n\n    return this;\n  }\n\n  /**\n   * Load injector from a given module\n   * @param rootModule\n   */\n  loadModule(rootModule: TokenProvider) {\n    this.settings.routes = this.settings.routes.concat(resolveControllers(this.settings));\n\n    const container = createContainer();\n    container.delete(rootModule);\n\n    container.addProvider(rootModule, {\n      type: \"server:module\",\n      scope: ProviderScope.SINGLETON\n    });\n\n    return this.load(container);\n  }\n\n  /**\n   * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.\n   *\n   * @param container\n   * @param rootModule\n   */\n  async load(container: Container = createContainer(), rootModule?: TokenProvider): Promise<LocalsContainer<any>> {\n    this.bootstrap(container);\n\n    // build async and sync provider\n    let locals = await this.loadAsync();\n\n    if (rootModule) {\n      await this.invoke(rootModule);\n    }\n\n    // load sync provider\n    locals = this.loadSync(locals);\n\n    await locals.emit(\"$beforeInit\");\n    await locals.emit(\"$onInit\");\n\n    return locals;\n  }\n\n  /**\n   * Load all configurations registered on providers\n   */\n  resolveConfiguration() {\n    if (this.resolvedConfiguration) {\n      return;\n    }\n    const mergedConfiguration = new Map();\n\n    super.forEach((provider) => {\n      if (provider.configuration && provider.type !== \"server:module\") {\n        Object.entries(provider.configuration).forEach(([key, value]) => {\n          if (![\"resolvers\", \"mount\", \"imports\"].includes(key)) {\n            value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);\n            mergedConfiguration.set(key, value);\n          }\n        });\n      }\n\n      if (provider.resolvers) {\n        this.resolvers.push(...provider.resolvers);\n      }\n    });\n\n    mergedConfiguration.forEach((value, key) => {\n      this.settings[key] = deepMerge(value, this.settings[key]);\n    });\n\n    this.settings.build();\n\n    this.resolvedConfiguration = true;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param locals\n   * @param options\n   */\n  public bindInjectableProperties(instance: any, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions>) {\n    const properties: InjectableProperties = ancestorsOf(classOf(instance)).reduce((properties: any, target: any) => {\n      const store = Store.from(target);\n\n      return {\n        ...properties,\n        ...(store.get(INJECTABLE_PROP) || {})\n      };\n    }, {});\n\n    Object.values(properties).forEach((definition) => {\n      switch (definition.bindingType) {\n        case InjectablePropertyType.METHOD:\n          this.bindMethod(instance, definition);\n          break;\n        case InjectablePropertyType.PROPERTY:\n          this.bindProperty(instance, definition, locals, options);\n          break;\n        case InjectablePropertyType.CONSTANT:\n          this.bindConstant(instance, definition);\n          break;\n        case InjectablePropertyType.VALUE:\n          this.bindValue(instance, definition);\n          break;\n        case InjectablePropertyType.INTERCEPTOR:\n          this.bindInterceptor(instance, definition);\n          break;\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  public bindMethod(instance: any, {propertyKey}: InjectablePropertyOptions) {\n    const target = classOf(instance);\n    const originalMethod = instance[propertyKey];\n    const deps = Metadata.getParamTypes(prototypeOf(target), propertyKey);\n\n    instance[propertyKey] = () => {\n      const services = deps.map((dependency: any) => this.get(dependency));\n\n      return originalMethod.call(instance, ...services);\n    };\n  }\n\n  /**\n   * Create an injectable property.\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   * @param resolver\n   * @param options\n   * @param locals\n   * @param invokeOptions\n   */\n  public bindProperty(\n    instance: any,\n    {propertyKey, resolver, options = {}}: InjectablePropertyOptions,\n    locals: Map<TokenProvider, any>,\n    invokeOptions: Partial<InvokeOptions>\n  ) {\n    let get: () => any;\n\n    get = resolver(this, locals, {...invokeOptions, options});\n\n    catchError(() =>\n      Object.defineProperty(instance, propertyKey, {\n        get\n      })\n    );\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindValue(instance: any, {propertyKey, expression, defaultValue}: InjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n\n    catchError(() => Object.defineProperty(instance, propertyKey, descriptor));\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindConstant(instance: any, {propertyKey, expression, defaultValue}: InjectablePropertyValue) {\n    let bean: any;\n\n    const get = () => {\n      if (bean !== undefined) {\n        return bean;\n      }\n\n      const value = this.settings.get(expression, defaultValue);\n      bean = Object.freeze(deepClone(value));\n\n      return bean;\n    };\n\n    const descriptor = {\n      get,\n      enumerable: true,\n      configurable: true\n    };\n\n    catchError(() => Object.defineProperty(instance, propertyKey, descriptor));\n  }\n\n  /**\n   *\n   * @param instance\n   * @param propertyKey\n   * @param useType\n   * @param options\n   */\n  public bindInterceptor(instance: any, {propertyKey, useType, options}: InjectablePropertyOptions) {\n    const target = classOf(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (...args: any[]) => {\n      const next = (err?: Error) => {\n        if (!err) {\n          return originalMethod.apply(instance, args);\n        }\n\n        throw err;\n      };\n\n      const context: InterceptorContext<any> = {\n        target,\n        propertyKey,\n        args,\n        options,\n        next\n      };\n\n      const interceptor = this.get<InterceptorMethods>(useType)!;\n\n      return interceptor.intercept!(\n        {\n          ...context,\n          options\n        },\n        next\n      );\n    };\n  }\n\n  async lazyInvoke<T = any>(token: TokenProvider) {\n    let instance = this.getInstance(token);\n\n    if (!instance) {\n      instance = await this.invoke<T>(token);\n\n      if (isFunction(instance?.$onInit)) {\n        await instance.$onInit();\n      }\n    }\n\n    return instance;\n  }\n\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  public async emit(eventName: string, ...args: any[]) {\n    return this.#cache.emit(eventName, ...args);\n  }\n\n  /**\n   * @param eventName\n   * @param value\n   * @param args\n   */\n  public alter<T = any>(eventName: string, value: any, ...args: any[]): T {\n    return this.#cache.alter(eventName, value, ...args);\n  }\n\n  /**\n   * @param eventName\n   * @param value\n   * @param args\n   */\n  public async alterAsync<T = any>(eventName: string, value: any, ...args: any[]): Promise<T> {\n    return this.#cache.alterAsync(eventName, value, ...args);\n  }\n\n  async destroy() {\n    await this.#cache.destroy();\n  }\n\n  protected ensureProvider(token: TokenProvider): Provider | undefined {\n    if (!this.hasProvider(token) && GlobalProviders.has(token)) {\n      this.addProvider(token);\n    }\n\n    return this.getProvider(token)!;\n  }\n\n  protected getInstance(token: any) {\n    return this.#cache.get(token);\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * @param target\n   * @param locals\n   * @param options\n   * @private\n   */\n  private resolve<T>(target: TokenProvider, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions<T>> = {}): Promise<T> {\n    const resolvedOpts = this.mapInvokeOptions(target, locals, options);\n    const {token, deps, construct, imports, provider} = resolvedOpts;\n\n    if (provider) {\n      GlobalProviders.onInvoke(provider, locals, {...resolvedOpts, injector: this});\n    }\n\n    let instance: any;\n    let currentDependency: any = false;\n\n    try {\n      const invokeDependency =\n        (parent?: any) =>\n        (token: any, index: number): any => {\n          currentDependency = {token, index, deps};\n\n          if (token !== DI_PARAM_OPTIONS) {\n            const options = provider?.store?.get(`${DI_PARAM_OPTIONS}:${index}`);\n\n            locals.set(DI_PARAM_OPTIONS, options || {});\n          }\n\n          return isInheritedFrom(token, Provider, 1) ? provider : this.invoke(token, locals, {parent});\n        };\n\n      // Invoke manually imported providers\n      imports.forEach(invokeDependency());\n\n      // Inject dependencies\n      const services = deps.map(invokeDependency(token));\n\n      currentDependency = false;\n\n      instance = construct(services);\n    } catch (error) {\n      InjectionError.throwInjectorError(token, currentDependency, error);\n    }\n\n    if (instance === undefined) {\n      throw new InjectionError(\n        token,\n        `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`\n      );\n    }\n\n    if (instance && isClass(classOf(instance))) {\n      this.bindInjectableProperties(instance, locals, options);\n    }\n\n    if (instance && provider.hooks) {\n      Object.entries(provider.hooks).forEach(([key, cb]) => {\n        instance[key] = (...args: any[]) => cb(instance, ...args);\n      });\n    }\n\n    return instance;\n  }\n\n  /**\n   * Create options to invoke a provider or class.\n   * @param token\n   * @param locals\n   * @param options\n   */\n  private mapInvokeOptions(token: TokenProvider, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions>): ResolvedInvokeOptions {\n    let imports: TokenProvider[] | undefined = options.imports;\n    let deps: TokenProvider[] | undefined = options.deps;\n    let scope = options.scope;\n    let construct;\n\n    if (!token) {\n      throw new UndefinedTokenError();\n    }\n\n    let provider: Provider;\n\n    if (!this.hasProvider(token)) {\n      provider = new Provider(token);\n\n      this.resolvers.forEach((resolver) => {\n        const result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));\n\n        if (result !== undefined) {\n          provider.useFactory = () => result;\n        }\n      });\n    } else {\n      provider = this.getProvider(token)!;\n    }\n\n    scope = scope || this.scopeOf(provider);\n    deps = deps || provider.deps;\n    imports = imports || provider.imports;\n\n    if (provider.useValue !== undefined) {\n      construct = () => (isFunction(provider.useValue) ? provider.useValue() : provider.useValue);\n    } else if (provider.useFactory) {\n      construct = (deps: TokenProvider[]) => provider.useFactory(...deps);\n    } else if (provider.useAsyncFactory) {\n      construct = async (deps: TokenProvider[]) => {\n        deps = await Promise.all(deps);\n        return provider.useAsyncFactory(...deps);\n      };\n    } else {\n      // useClass\n      deps = deps || Metadata.getParamTypes(provider.useClass);\n      construct = (deps: TokenProvider[]) => new provider.useClass(...deps);\n    }\n\n    return {\n      token,\n      scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n      deps: deps! || [],\n      imports: imports || [],\n      construct,\n      provider\n    };\n  }\n}\n"]}