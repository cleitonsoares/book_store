{"version":3,"file":"inject.js","sourceRoot":"","sources":["../../../src/decorators/inject.ts"],"names":[],"mappings":"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","sourcesContent":["import {decoratorTypeOf, DecoratorTypes, isPromise, Metadata, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants/constants\";\nimport type {InjectablePropertyOptions} from \"../interfaces/InjectableProperties\";\nimport {getContext} from \"../utils/runInContext\";\n\nexport function injectProperty(target: any, propertyKey: string, options: Partial<InjectablePropertyOptions>) {\n  Store.from(target).merge(INJECTABLE_PROP, {\n    [propertyKey]: {\n      bindingType: DecoratorTypes.PROP,\n      propertyKey,\n      ...options\n    }\n  });\n}\n\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param symbol\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(symbol?: any, onGet = (bean: any) => bean): Function {\n  return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<Function> | number): any | void => {\n    const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM:\n      case DecoratorTypes.PARAM_CTOR:\n        if (symbol) {\n          const paramTypes = Metadata.getParamTypes(target, propertyKey);\n\n          paramTypes[descriptor as number] = symbol;\n          Metadata.setParamTypes(target, propertyKey, paramTypes);\n        }\n        break;\n\n      case DecoratorTypes.PROP:\n        injectProperty(target, propertyKey, {\n          resolver(injector, locals, {options, ...invokeOptions}) {\n            locals.set(DI_PARAM_OPTIONS, {...options});\n\n            let bean: any;\n\n            if (!bean) {\n              const useType = symbol || Metadata.getType(target, propertyKey);\n              bean = injector.invoke(useType, locals, invokeOptions);\n              locals.delete(DI_PARAM_OPTIONS);\n            }\n\n            if (isPromise(bean)) {\n              bean.then((result: any) => {\n                bean = result;\n              });\n            }\n\n            return () => onGet(bean);\n          }\n        });\n        break;\n\n      case DecoratorTypes.METHOD:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey]: {\n            bindingType,\n            propertyKey\n          }\n        });\n\n        return descriptor;\n\n      default:\n        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n    }\n  };\n}\n\n/**\n * Inject a context like PlatformContext or any BaseContext.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @InjectContext()\n *   ctx?: Context;\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n */\nexport function InjectContext(): PropertyDecorator {\n  return (target: any, propertyKey: string): any | void => {\n    injectProperty(target, propertyKey, {\n      resolver() {\n        return () => getContext();\n      }\n    });\n  };\n}\n"]}