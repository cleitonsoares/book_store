import { levels } from "@tsed/logger";
export class ContextLogger {
    constructor(logger, { id, url = "", dateStart = new Date(), ignoreUrlPatterns = [], minimalRequestPicker, completeRequestPicker, level = "all", maxStackSize = 30, ignoreLog, additionalProps }) {
        this.logger = logger;
        this.stack = [];
        this.id = id;
        this.url = url;
        this.additionalProps = additionalProps || {};
        this.dateStart = dateStart;
        this.ignoreLog = ignoreLog || (() => false);
        this.minimalRequestPicker = minimalRequestPicker || ((l) => l);
        this.completeRequestPicker = completeRequestPicker || ((l) => l);
        // @ts-ignore
        this.level = levels()[level.toUpperCase()] || levels().ALL;
        this.maxStackSize = maxStackSize;
    }
    info(obj) {
        this.run(levels().INFO, obj, (obj) => this.minimalRequestPicker(this.getData(obj)));
        return this;
    }
    debug(obj, withRequest = true) {
        this.run(levels().DEBUG, obj, (obj) => {
            obj = this.getData(obj);
            return withRequest ? this.completeRequestPicker(obj) : obj;
        });
        return this;
    }
    warn(obj) {
        this.run(levels().WARN, obj, (obj) => this.completeRequestPicker(this.getData(obj)));
        return this;
    }
    error(obj) {
        this.run(levels().ERROR, obj, (obj) => this.completeRequestPicker(this.getData(obj)));
        return this;
    }
    trace(obj) {
        this.run(levels().TRACE, obj, (obj) => this.completeRequestPicker(this.getData(obj)));
        return this;
    }
    flush() {
        if (this.stack.length) {
            this.stack.forEach(({ level, data }) => {
                this.logger[level](data);
            });
            this.stack = [];
        }
    }
    isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
    }
    destroy() {
        this.flush();
        this.logger = undefined;
        this.stack = undefined;
    }
    /**
     * Return the duration between the time when LogIncomingRequest has handle the request and now.
     * @returns {number}
     */
    getDuration() {
        return new Date().getTime() - this.dateStart.getTime();
    }
    getData(obj) {
        if (typeof obj === "string") {
            obj = { message: obj };
        }
        return { ...this.additionalProps, reqId: this.id, time: new Date(), duration: this.getDuration(), ...obj };
    }
    run(level, obj, mapper) {
        if (!this.isLevelEnabled(level)) {
            return;
        }
        if (!this.ignoreLog(obj)) {
            this.stack.push({ level: level.levelStr.toLowerCase(), data: mapper(obj) });
        }
        if (this.maxStackSize < this.stack.length) {
            this.flush();
        }
    }
}
//# sourceMappingURL=ContextLogger.js.map