import { Store, Type } from "@tsed/core";
import { ProviderOpts } from "../interfaces/ProviderOpts";
import { TokenProvider } from "../interfaces/TokenProvider";
import { ProviderScope } from "./ProviderScope";
import { ProviderType } from "./ProviderType";
export declare class Provider<T = any> implements ProviderOpts<T> {
    type: ProviderType | any;
    /**
     * @deprecated Use injector.get(provider.token) instead.
     */
    instance: T;
    deps: TokenProvider[];
    imports: any[];
    useFactory: Function;
    useAsyncFactory: Function;
    useValue: any;
    hooks?: Record<string, (instance: T, ...args: any[]) => Promise<void> | void>;
    private _useClass;
    private _provide;
    private _store;
    private _tokenStore;
    [key: string]: any;
    constructor(token: TokenProvider, options?: Partial<Provider>);
    get token(): any;
    get provide(): TokenProvider;
    set provide(value: TokenProvider);
    get useClass(): Type<T>;
    /**
     * Create a new store if the given value is a class. Otherwise the value is ignored.
     * @param value
     */
    set useClass(value: Type<T>);
    get className(): string;
    get name(): string;
    get store(): Store;
    get path(): string;
    set path(path: string);
    /**
     * Get the scope of the provider.
     *
     * ::: tip Note
     * Async provider is always a SINGLETON
     * :::
     *
     * @returns {boolean}
     */
    get scope(): ProviderScope;
    /**
     * Change the scope value of the provider.
     * @param scope
     */
    set scope(scope: ProviderScope);
    get configuration(): Partial<TsED.Configuration>;
    set configuration(configuration: Partial<TsED.Configuration>);
    get children(): TokenProvider[];
    get(key: string): any;
    isAsync(): boolean;
    clone(): Provider;
    /**
     *
     * @returns {boolean}
     */
    hasChildren(): boolean;
    /**
     *
     * @returns {boolean}
     */
    hasParent(): boolean;
    toString(): string;
}
