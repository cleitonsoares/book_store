"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.plainObjectToClass = void 0;
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
require("../components/ArrayMapper");
require("../components/DateMapper");
require("../components/MapMapper");
require("../components/PrimitiveMapper");
require("../components/SetMapper");
require("../components/SymbolMapper");
const JsonMapperContext_1 = require("../domain/JsonMapperContext");
const JsonMapperTypesContainer_1 = require("../domain/JsonMapperTypesContainer");
const alterAfterDeserialize_1 = require("../hooks/alterAfterDeserialize");
const alterBeforeDeserialize_1 = require("../hooks/alterBeforeDeserialize");
function isDeserializable(obj, options) {
    if ((!!options.collectionType && (0, core_1.isNil)(obj)) || obj === undefined) {
        return false;
    }
    return !((0, core_1.isEmpty)(options.type) || (options.type === Object && !options.collectionType));
}
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onDeserialize", value, [options]);
}
function transformCollection(src, options) {
    var _a;
    const { types, type = Object, collectionType } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        collectionType,
        options,
        next: (data, { collectionType, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(options.collectionType)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
function transformType(src, options) {
    var _a;
    const { types, type = Object } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        options,
        next: (data, { type, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(type)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
function mapItemOptions(propStore, options) {
    const itemOpts = {
        ...options,
        store: undefined,
        type: propStore.computedType
    };
    if (propStore.schema.hasGenerics) {
        itemOpts.nestedGenerics = propStore.schema.nestedGenerics;
    }
    else if (propStore.schema.isGeneric && options.nestedGenerics) {
        const [genericTypes = [], ...nestedGenerics] = options.nestedGenerics;
        const genericLabels = propStore.parent.schema.genericLabels || [];
        itemOpts.type = genericTypes[genericLabels.indexOf(propStore.schema.genericType)] || Object;
        if (itemOpts.type instanceof schema_1.JsonSchema) {
            itemOpts.type = itemOpts.type.getTarget();
        }
        itemOpts.nestedGenerics = nestedGenerics;
    }
    return itemOpts;
}
/**
 * Transform given plain object to class.
 * @param src
 * @param options
 */
function plainObjectToClass(src, options) {
    if ((0, core_1.isEmpty)(src)) {
        return src;
    }
    const { type, store = schema_1.JsonEntityStore.from(type) } = options;
    const propertiesMap = (0, schema_1.getProperties)(store, { ...options, withIgnoredProps: true });
    let keys = new Set((0, core_1.objectKeys)(src));
    const additionalProperties = propertiesMap.size ? !!store.schema.get("additionalProperties") || options.additionalProperties : true;
    src = (0, alterBeforeDeserialize_1.alterBeforeDeserialize)(src, store.schema, options);
    const out = new type(src);
    propertiesMap.forEach((propStore) => {
        const key = options.useAlias
            ? propStore.parent.schema.getAliasOf(propStore.propertyName) || propStore.propertyName
            : propStore.propertyName;
        keys.delete(key);
        if ((0, schema_1.alterIgnore)(propStore.schema, options)) {
            return;
        }
        let value = alterValue(propStore.schema, src[key], { ...options, self: src });
        const itemOptions = mapItemOptions(propStore, options);
        value = deserialize(value, {
            ...itemOptions,
            self: src,
            type: value === src[key] ? itemOptions.type : undefined,
            collectionType: propStore.collectionType
        });
        if (value !== undefined) {
            out[propStore.propertyName] = value;
        }
    });
    if (additionalProperties) {
        keys.forEach((key) => {
            out[key] = src[key];
        });
    }
    return (0, alterAfterDeserialize_1.alterAfterDeserialize)(out, store.schema, options);
}
exports.plainObjectToClass = plainObjectToClass;
function buildOptions(options) {
    if (options.store instanceof schema_1.JsonEntityStore) {
        if (options.store.parameter && options.store.parameter.nestedGenerics.length) {
            options.nestedGenerics = options.store.parameter.nestedGenerics;
        }
        options.type = options.store.computedType;
        options.collectionType = options.store.collectionType;
        delete options.store;
    }
    return {
        groups: false,
        useAlias: true,
        ...options,
        type: options.type ? options.type : undefined,
        types: options.types ? options.types : (0, JsonMapperTypesContainer_1.getJsonMapperTypes)()
    };
}
/**
 * Transform given source to class base on the given `options.type`.
 *
 * @param src
 * @param options
 */
function deserialize(src, options = {}) {
    var _a, _b;
    options = buildOptions(options);
    if (!isDeserializable(src, options)) {
        return src;
    }
    if (!options.collectionType && (0, core_1.isArray)(src)) {
        options.collectionType = Array;
    }
    if (options.collectionType) {
        if (!((_a = options.types) === null || _a === void 0 ? void 0 : _a.has(options.collectionType))) {
            throw new Error(`${(0, core_1.nameOf)(options.collectionType)} is not supported by JsonMapper.`);
        }
        return transformCollection(src, options);
    }
    if ((_b = options.types) === null || _b === void 0 ? void 0 : _b.has(options.type)) {
        return transformType(src, options);
    }
    // class converter
    return plainObjectToClass(src, options);
}
exports.deserialize = deserialize;
//# sourceMappingURL=deserialize.js.map