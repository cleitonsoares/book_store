import { isArray, isEmpty, isNil, nameOf, objectKeys } from "@tsed/core";
import { alterIgnore, getProperties, JsonEntityStore, JsonSchema } from "@tsed/schema";
import "../components/ArrayMapper.js";
import "../components/DateMapper.js";
import "../components/MapMapper.js";
import "../components/PrimitiveMapper.js";
import "../components/SetMapper.js";
import "../components/SymbolMapper.js";
import { JsonMapperContext } from "../domain/JsonMapperContext.js";
import { getJsonMapperTypes } from "../domain/JsonMapperTypesContainer.js";
import { alterAfterDeserialize } from "../hooks/alterAfterDeserialize.js";
import { alterBeforeDeserialize } from "../hooks/alterBeforeDeserialize.js";
function isDeserializable(obj, options) {
    if ((!!options.collectionType && isNil(obj)) || obj === undefined) {
        return false;
    }
    return !(isEmpty(options.type) || (options.type === Object && !options.collectionType));
}
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onDeserialize", value, [options]);
}
function transformCollection(src, options) {
    var _a;
    const { types, type = Object, collectionType } = options;
    const context = new JsonMapperContext({
        type,
        collectionType,
        options,
        next: (data, { collectionType, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(options.collectionType)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
function transformType(src, options) {
    var _a;
    const { types, type = Object } = options;
    const context = new JsonMapperContext({
        type,
        options,
        next: (data, { type, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(type)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
function mapItemOptions(propStore, options) {
    const itemOpts = {
        ...options,
        store: undefined,
        type: propStore.computedType
    };
    if (propStore.schema.hasGenerics) {
        itemOpts.nestedGenerics = propStore.schema.nestedGenerics;
    }
    else if (propStore.schema.isGeneric && options.nestedGenerics) {
        const [genericTypes = [], ...nestedGenerics] = options.nestedGenerics;
        const genericLabels = propStore.parent.schema.genericLabels || [];
        itemOpts.type = genericTypes[genericLabels.indexOf(propStore.schema.genericType)] || Object;
        if (itemOpts.type instanceof JsonSchema) {
            itemOpts.type = itemOpts.type.getTarget();
        }
        itemOpts.nestedGenerics = nestedGenerics;
    }
    return itemOpts;
}
/**
 * Transform given plain object to class.
 * @param src
 * @param options
 */
export function plainObjectToClass(src, options) {
    if (isEmpty(src)) {
        return src;
    }
    const { type, store = JsonEntityStore.from(type) } = options;
    const propertiesMap = getProperties(store, { ...options, withIgnoredProps: true });
    let keys = new Set(objectKeys(src));
    const additionalProperties = propertiesMap.size ? !!store.schema.get("additionalProperties") || options.additionalProperties : true;
    src = alterBeforeDeserialize(src, store.schema, options);
    const out = new type(src);
    propertiesMap.forEach((propStore) => {
        const key = options.useAlias
            ? propStore.parent.schema.getAliasOf(propStore.propertyName) || propStore.propertyName
            : propStore.propertyName;
        keys.delete(key);
        if (alterIgnore(propStore.schema, options)) {
            return;
        }
        let value = alterValue(propStore.schema, src[key], { ...options, self: src });
        const itemOptions = mapItemOptions(propStore, options);
        value = deserialize(value, {
            ...itemOptions,
            self: src,
            type: value === src[key] ? itemOptions.type : undefined,
            collectionType: propStore.collectionType
        });
        if (value !== undefined) {
            out[propStore.propertyName] = value;
        }
    });
    if (additionalProperties) {
        keys.forEach((key) => {
            out[key] = src[key];
        });
    }
    return alterAfterDeserialize(out, store.schema, options);
}
function buildOptions(options) {
    if (options.store instanceof JsonEntityStore) {
        if (options.store.parameter && options.store.parameter.nestedGenerics.length) {
            options.nestedGenerics = options.store.parameter.nestedGenerics;
        }
        options.type = options.store.computedType;
        options.collectionType = options.store.collectionType;
        delete options.store;
    }
    return {
        groups: false,
        useAlias: true,
        ...options,
        type: options.type ? options.type : undefined,
        types: options.types ? options.types : getJsonMapperTypes()
    };
}
/**
 * Transform given source to class base on the given `options.type`.
 *
 * @param src
 * @param options
 */
export function deserialize(src, options = {}) {
    var _a, _b;
    options = buildOptions(options);
    if (!isDeserializable(src, options)) {
        return src;
    }
    if (!options.collectionType && isArray(src)) {
        options.collectionType = Array;
    }
    if (options.collectionType) {
        if (!((_a = options.types) === null || _a === void 0 ? void 0 : _a.has(options.collectionType))) {
            throw new Error(`${nameOf(options.collectionType)} is not supported by JsonMapper.`);
        }
        return transformCollection(src, options);
    }
    if ((_b = options.types) === null || _b === void 0 ? void 0 : _b.has(options.type)) {
        return transformType(src, options);
    }
    // class converter
    return plainObjectToClass(src, options);
}
//# sourceMappingURL=deserialize.js.map