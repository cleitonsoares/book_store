var _PerfLogger_perf, _PerfLogger_enabled;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { classOf, descriptorOf, methodsOf, nameOf } from "@tsed/core";
import chalk from "chalk";
import { Perf } from "./Perf.js";
const loggers = new Map();
// istanbul ignore next
export class PerfLogger {
    constructor(label = "perf", levels = { 10: "green", 50: "yellow", 100: "red" }) {
        this.label = label;
        this.levels = levels;
        _PerfLogger_perf.set(this, new Perf());
        _PerfLogger_enabled.set(this, false);
        this.wrap = this.wrap.bind(this);
        this.log = this.log.bind(this);
        this.start = this.start.bind(this);
        this.end = this.end.bind(this);
        this.bind = this.bind.bind(this);
    }
    static get(label) {
        if (loggers.get(label)) {
            return loggers.get(label);
        }
        const logger = loggers.get(label) || new PerfLogger(label);
        loggers.set(label, logger);
        return logger;
    }
    start() {
        __classPrivateFieldSet(this, _PerfLogger_enabled, true, "f");
        __classPrivateFieldGet(this, _PerfLogger_perf, "f").start();
        return this;
    }
    log(...args) {
        if (__classPrivateFieldGet(this, _PerfLogger_enabled, "f")) {
            console.debug(this.formatLog(["LOG   -", ...args], __classPrivateFieldGet(this, _PerfLogger_perf, "f").fromLatest(), "from latest: "));
        }
        return this;
    }
    bind(instance) {
        const methods = methodsOf(classOf(instance));
        const { wrap, log } = this;
        methods.forEach(({ target, propertyKey }) => {
            const descriptor = descriptorOf(target, propertyKey);
            const name = nameOf(target);
            if (descriptor.value) {
                const fn = instance[propertyKey].bind(instance);
                if (propertyKey === "log") {
                    instance[propertyKey] = (...args) => {
                        log(...args);
                        return fn(...args);
                    };
                }
                else {
                    instance[propertyKey] = (...args) => {
                        return wrap(() => fn(...args), `${name}.${propertyKey}()`);
                    };
                }
            }
        });
        return instance;
    }
    wrap(fn, name = nameOf(fn)) {
        if (!__classPrivateFieldGet(this, _PerfLogger_enabled, "f")) {
            return fn();
        }
        console.debug(this.formatLog([`START - ${name}`], __classPrivateFieldGet(this, _PerfLogger_perf, "f").fromLatest(), "from latest: "));
        return __classPrivateFieldGet(this, _PerfLogger_perf, "f").run(fn, (time) => {
            if (__classPrivateFieldGet(this, _PerfLogger_enabled, "f")) {
                console.debug(this.formatLog([`END   - ${name}`], time, "method: "));
            }
        });
    }
    end() {
        if (__classPrivateFieldGet(this, _PerfLogger_enabled, "f")) {
            console.debug(this.formatLog(["ending"], __classPrivateFieldGet(this, _PerfLogger_perf, "f").end(), "from start: "));
            __classPrivateFieldSet(this, _PerfLogger_enabled, false, "f");
        }
        return this;
    }
    formatLog(log, diff, wrap = "") {
        const dataLog = log.join(" ") + "                                                                                    ";
        const diffLabel = this.formatDiff(diff, wrap);
        const fromStart = __classPrivateFieldGet(this, _PerfLogger_perf, "f").fromStart();
        const globalDiff = ("     " + fromStart.toFixed(3) + "ms").slice(-10);
        return `[${this.label}] ${globalDiff} - ${String(dataLog)}`.slice(0, 80) + ` ${diffLabel}`;
    }
    formatDiff(diff, prefix = "") {
        const label = `(${prefix}+${diff}ms)`;
        const list = Object.entries(this.levels);
        const [, color] = list.find(([level]) => diff <= +level) || list[list.length - 1];
        return chalk[color](label);
    }
}
_PerfLogger_perf = new WeakMap(), _PerfLogger_enabled = new WeakMap();
//# sourceMappingURL=PerfLogger.js.map