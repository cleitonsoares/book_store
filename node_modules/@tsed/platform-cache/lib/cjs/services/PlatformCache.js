"use strict";
var _PlatformCache_cache;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformCache = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const logger_1 = require("@tsed/logger");
const defaultKeyResolver = (args) => {
    return args.map((arg) => ((0, core_1.isClass)(arg) ? JSON.stringify((0, json_mapper_1.serialize)(arg)) : arg)).join(":");
};
/**
 * @platform
 */
let PlatformCache = class PlatformCache {
    constructor() {
        _PlatformCache_cache.set(this, void 0);
    }
    get cache() {
        return tslib_1.__classPrivateFieldGet(this, _PlatformCache_cache, "f");
    }
    async $onInit() {
        const settings = this.settings.get("cache");
        if (settings) {
            tslib_1.__classPrivateFieldSet(this, _PlatformCache_cache, await this.createCacheManager(settings), "f");
            await this.injector.emit("$onCreateCacheManager", tslib_1.__classPrivateFieldGet(this, _PlatformCache_cache, "f"));
        }
    }
    disabled() {
        return !this.settings.get("cache");
    }
    defaultKeyResolver() {
        return this.settings.get("cache.keyResolver", defaultKeyResolver);
    }
    defaultTtl() {
        return this.settings.get("cache.ttl");
    }
    calculateTTL(result, currentTtl) {
        const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
        return (0, core_1.isFunction)(ttl) ? ttl(result) : ttl;
    }
    async ttl(key) {
        if (this.cache && "store" in this.cache && this.cache.store.ttl) {
            return this.cache.store.ttl(key);
        }
    }
    wrap(key, fetch, options) {
        var _a;
        if (!this.cache) {
            return fetch();
        }
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.wrap(key, fetch, options);
    }
    async get(key, options = {}) {
        var _a;
        return (0, json_mapper_1.deserialize)((_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(key), options);
    }
    async set(key, value, options) {
        var _a;
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.set(key, value, options);
    }
    async getCachedObject(key) {
        try {
            return await this.get(key);
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "getCachedObject",
                error: er
            });
        }
    }
    async setCachedObject(key, data, opts) {
        try {
            await this.set(key, {
                ...opts,
                data: JSON.stringify(data)
            }, {
                ttl: opts.ttl
            });
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "setCachedObject",
                error: er
            });
        }
    }
    async del(key) {
        var _a;
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.del(key));
    }
    async reset() {
        var _a;
        // @ts-ignore
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.reset());
    }
    async keys(...args) {
        if (this.cache && "store" in this.cache && this.cache.store.keys) {
            return this.cache.store.keys(...args);
        }
        // istanbul ignore next
        return [];
    }
    async getMatchingKeys(patterns) {
        const [keys, { default: micromatch }] = await Promise.all([this.keys(), Promise.resolve().then(() => tslib_1.__importStar(require("micromatch")))]);
        return micromatch(keys, patterns);
    }
    async deleteMatchingKeys(patterns) {
        const keys = await this.getMatchingKeys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    async createCacheManager(settings) {
        const { caches, store = "memory", ttl, ...props } = settings;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { default: cacheManager } = await Promise.resolve().then(() => tslib_1.__importStar(require("cache-manager")));
        return (caches === null || caches === void 0 ? void 0 : caches.length)
            ? cacheManager.multiCaching(caches, { ...props })
            : cacheManager.caching({
                ...props,
                ttl,
                store: (0, core_1.isFunction)(store) ? await store() : store
            });
    }
};
_PlatformCache_cache = new WeakMap();
tslib_1.__decorate([
    (0, di_1.Configuration)(),
    tslib_1.__metadata("design:type", Object)
], PlatformCache.prototype, "settings", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformCache.prototype, "injector", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], PlatformCache.prototype, "logger", void 0);
PlatformCache = tslib_1.__decorate([
    (0, di_1.Module)()
], PlatformCache);
exports.PlatformCache = PlatformCache;
//# sourceMappingURL=PlatformCache.js.map