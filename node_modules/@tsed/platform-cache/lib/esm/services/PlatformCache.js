var _PlatformCache_cache;
import { __classPrivateFieldGet, __classPrivateFieldSet, __decorate, __metadata } from "tslib";
import { isClass, isFunction } from "@tsed/core";
import { Configuration, Inject, InjectorService, Module } from "@tsed/di";
import { deserialize, serialize } from "@tsed/json-mapper";
import { Logger } from "@tsed/logger";
const defaultKeyResolver = (args) => {
    return args.map((arg) => (isClass(arg) ? JSON.stringify(serialize(arg)) : arg)).join(":");
};
/**
 * @platform
 */
let PlatformCache = class PlatformCache {
    constructor() {
        _PlatformCache_cache.set(this, void 0);
    }
    get cache() {
        return __classPrivateFieldGet(this, _PlatformCache_cache, "f");
    }
    async $onInit() {
        const settings = this.settings.get("cache");
        if (settings) {
            __classPrivateFieldSet(this, _PlatformCache_cache, await this.createCacheManager(settings), "f");
            await this.injector.emit("$onCreateCacheManager", __classPrivateFieldGet(this, _PlatformCache_cache, "f"));
        }
    }
    disabled() {
        return !this.settings.get("cache");
    }
    defaultKeyResolver() {
        return this.settings.get("cache.keyResolver", defaultKeyResolver);
    }
    defaultTtl() {
        return this.settings.get("cache.ttl");
    }
    calculateTTL(result, currentTtl) {
        const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
        return isFunction(ttl) ? ttl(result) : ttl;
    }
    async ttl(key) {
        if (this.cache && "store" in this.cache && this.cache.store.ttl) {
            return this.cache.store.ttl(key);
        }
    }
    wrap(key, fetch, options) {
        var _a;
        if (!this.cache) {
            return fetch();
        }
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.wrap(key, fetch, options);
    }
    async get(key, options = {}) {
        var _a;
        return deserialize((_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(key), options);
    }
    async set(key, value, options) {
        var _a;
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.set(key, value, options);
    }
    async getCachedObject(key) {
        try {
            return await this.get(key);
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "getCachedObject",
                error: er
            });
        }
    }
    async setCachedObject(key, data, opts) {
        try {
            await this.set(key, {
                ...opts,
                data: JSON.stringify(data)
            }, {
                ttl: opts.ttl
            });
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "setCachedObject",
                error: er
            });
        }
    }
    async del(key) {
        var _a;
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.del(key));
    }
    async reset() {
        var _a;
        // @ts-ignore
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.reset());
    }
    async keys(...args) {
        if (this.cache && "store" in this.cache && this.cache.store.keys) {
            return this.cache.store.keys(...args);
        }
        // istanbul ignore next
        return [];
    }
    async getMatchingKeys(patterns) {
        const [keys, { default: micromatch }] = await Promise.all([this.keys(), import("micromatch")]);
        return micromatch(keys, patterns);
    }
    async deleteMatchingKeys(patterns) {
        const keys = await this.getMatchingKeys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    async createCacheManager(settings) {
        const { caches, store = "memory", ttl, ...props } = settings;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { default: cacheManager } = await import("cache-manager");
        return (caches === null || caches === void 0 ? void 0 : caches.length)
            ? cacheManager.multiCaching(caches, { ...props })
            : cacheManager.caching({
                ...props,
                ttl,
                store: isFunction(store) ? await store() : store
            });
    }
};
_PlatformCache_cache = new WeakMap();
__decorate([
    Configuration(),
    __metadata("design:type", Object)
], PlatformCache.prototype, "settings", void 0);
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], PlatformCache.prototype, "injector", void 0);
__decorate([
    Inject(),
    __metadata("design:type", Logger)
], PlatformCache.prototype, "logger", void 0);
PlatformCache = __decorate([
    Module()
], PlatformCache);
export { PlatformCache };
//# sourceMappingURL=PlatformCache.js.map