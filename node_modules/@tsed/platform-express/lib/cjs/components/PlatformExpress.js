"use strict";
var _PlatformExpress_multer;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformExpress = void 0;
const tslib_1 = require("tslib");
const express_1 = tslib_1.__importDefault(require("express"));
const common_1 = require("@tsed/common");
const util_1 = require("util");
const core_1 = require("@tsed/core");
const PlatformExpressHandler_1 = require("../services/PlatformExpressHandler");
const PlatformExpressResponse_1 = require("../services/PlatformExpressResponse");
const PlatformExpressRequest_1 = require("../services/PlatformExpressRequest");
const staticsMiddleware_1 = require("../middlewares/staticsMiddleware");
/**
 * @platform
 * @express
 */
class PlatformExpress {
    constructor(injector) {
        this.injector = injector;
        this.providers = [
            {
                provide: common_1.PlatformHandler,
                useClass: PlatformExpressHandler_1.PlatformExpressHandler
            },
            {
                provide: common_1.PlatformResponse,
                useClass: PlatformExpressResponse_1.PlatformExpressResponse
            },
            {
                provide: common_1.PlatformRequest,
                useClass: PlatformExpressRequest_1.PlatformExpressRequest
            }
        ];
        _PlatformExpress_multer.set(this, void 0);
        Promise.resolve().then(() => tslib_1.__importStar(require("multer"))).then(({ default: multer }) => (tslib_1.__classPrivateFieldSet(this, _PlatformExpress_multer, multer, "f")));
    }
    /**
     * Create new serverless application. In this mode, the component scan are disabled.
     * @param module
     * @param settings
     */
    static create(module, settings = {}) {
        return common_1.PlatformBuilder.create(module, {
            ...settings,
            adapter: PlatformExpress
        });
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static async bootstrap(module, settings = {}) {
        return common_1.PlatformBuilder.bootstrap(module, {
            ...settings,
            adapter: PlatformExpress
        });
    }
    onInit() {
        this.injector.settings.middlewares = (this.injector.settings.middlewares || []).filter((middleware) => {
            const name = (0, core_1.nameOf)(middleware);
            if (["textParser", "jsonParser", "rawParser", "urlencodedParser"].includes(name)) {
                this.injector.settings.set(`express.bodyParser.${name.replace("Parser", "")}`, () => middleware);
                return false;
            }
            return true;
        });
    }
    useRouter() {
        const { logger } = this.injector;
        const app = this.injector.get(common_1.PlatformApplication);
        logger.debug("Mount app router");
        app.getApp().use(app.getRouter());
        return this;
    }
    async beforeLoadRoutes() {
        const injector = this.injector;
        const app = this.injector.get(common_1.PlatformApplication);
        // disable x-powered-by header
        injector.settings.get("env") === core_1.Env.PROD && app.getApp().disable("x-powered-by");
        await this.configureViewsEngine();
    }
    async afterLoadRoutes() {
        const injector = this.injector;
        const app = this.injector.get(common_1.PlatformApplication);
        // NOT FOUND
        app.use((req, res, next) => {
            var _a;
            !res.headersSent && ((_a = injector.get(common_1.PlatformExceptions)) === null || _a === void 0 ? void 0 : _a.resourceNotFound(req.$ctx));
        });
        // EXCEPTION FILTERS
        app.use((err, req, res, next) => {
            var _a;
            !res.headersSent && ((_a = injector.get(common_1.PlatformExceptions)) === null || _a === void 0 ? void 0 : _a.catch(err, req.$ctx));
        });
    }
    useContext() {
        const { logger } = this.injector;
        logger.debug("Mount app context");
        const invoke = (0, common_1.createContext)(this.injector);
        const app = this.injector.get(common_1.PlatformApplication);
        app.getApp().use(async (request, response, next) => {
            await invoke({ request, response });
            return next();
        });
        return this;
    }
    multipart(options) {
        const m = tslib_1.__classPrivateFieldGet(this, _PlatformExpress_multer, "f").call(this, options);
        const makePromise = (multer, name) => {
            // istanbul ignore next
            if (!multer[name])
                return;
            const fn = multer[name];
            multer[name] = function apply(...args) {
                const middleware = Reflect.apply(fn, this, args);
                return (req, res) => (0, util_1.promisify)(middleware)(req, res);
            };
        };
        makePromise(m, "any");
        makePromise(m, "array");
        makePromise(m, "fields");
        makePromise(m, "none");
        makePromise(m, "single");
        return m;
    }
    app() {
        const app = this.injector.settings.get("express.app") || (0, express_1.default)();
        return {
            app,
            callback() {
                return app;
            }
        };
    }
    router(routerOptions = {}) {
        var _a;
        const options = Object.assign({
            mergeParams: true
        }, ((_a = this.injector.settings.express) === null || _a === void 0 ? void 0 : _a.router) || {}, routerOptions);
        const router = express_1.default.Router(options);
        return {
            router,
            callback() {
                return router;
            }
        };
    }
    statics(endpoint, options) {
        const { root, ...props } = options;
        return (0, staticsMiddleware_1.staticsMiddleware)(root, props);
    }
    bodyParser(type, additionalOptions = {}) {
        const opts = this.injector.settings.get(`express.bodyParser.${type}`);
        let parser = express_1.default[type];
        let options = {};
        if ((0, core_1.isFunction)(opts)) {
            parser = opts;
            options = {};
        }
        switch (type) {
            case "urlencoded":
                options.extended = true;
                break;
            case "raw":
                options.type = () => true;
                break;
        }
        return parser({ ...options, ...additionalOptions });
    }
    async configureViewsEngine() {
        const injector = this.injector;
        const app = this.injector.get(common_1.PlatformApplication);
        try {
            const { exists, disabled } = this.injector.settings.get("views") || {};
            if (exists && !disabled) {
                const { PlatformViews } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/platform-views")));
                const platformViews = injector.get(PlatformViews);
                const express = app.getApp();
                platformViews.getEngines().forEach(({ extension, engine }) => {
                    express.engine(extension, engine.render);
                });
                platformViews.viewEngine && express.set("view engine", platformViews.viewEngine);
                platformViews.root && express.set("views", platformViews.root);
            }
        }
        catch (error) {
            // istanbul ignore next
            injector.logger.warn({
                event: "PLATFORM_VIEWS_ERROR",
                message: "Unable to configure the PlatformViews service on your environment.",
                error
            });
        }
    }
}
exports.PlatformExpress = PlatformExpress;
_PlatformExpress_multer = new WeakMap();
//# sourceMappingURL=PlatformExpress.js.map