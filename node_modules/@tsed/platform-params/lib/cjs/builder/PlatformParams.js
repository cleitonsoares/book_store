"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformParams = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const ParamValidationError_1 = require("../errors/ParamValidationError");
const ParseExpressionPipe_1 = require("../pipes/ParseExpressionPipe");
/**
 * Platform Params abstraction layer.
 * @platform
 */
let PlatformParams = class PlatformParams {
    async getPipes(param) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        const map = (token) => this.injector.invoke(token);
        const promises = await Promise.all([ParseExpressionPipe_1.ParseExpressionPipe, ...param.pipes.sort(sort)].map(map));
        return promises.filter(Boolean);
    }
    async compile(entity) {
        const params = schema_1.JsonParameterStore.getParams(entity.target, entity.propertyKey);
        const argsPipes = await Promise.all(params.map(async (param) => {
            return {
                param,
                pipes: await this.getPipes(param)
            };
        }));
        return (scope) => {
            const promises = argsPipes.map(({ param, pipes }) => {
                return this.getArg(scope, pipes, param);
            });
            return Promise.all(promises);
        };
    }
    async getArg(scope, pipes, param) {
        return pipes.reduce(async (value, pipe) => {
            value = await value;
            try {
                return await pipe.transform(value, param);
            }
            catch (er) {
                throw ParamValidationError_1.ParamValidationError.from(param, er);
            }
        }, scope);
    }
    async compileHandler(metadata) {
        const { token, propertyKey, getCustomArgs } = metadata;
        const provider = this.injector.getProvider(token);
        const getArguments = getCustomArgs || (await this.compile(schema_1.JsonEntityStore.fromMethod(token, propertyKey)));
        if (!provider || !provider.scope || provider.scope === di_1.ProviderScope.SINGLETON) {
            const instance = await this.injector.invoke(token);
            const handler = instance[propertyKey].bind(instance);
            return async (scope) => {
                const args = await getArguments(scope);
                return handler(...args, scope.$ctx);
            };
        }
        return async (scope) => {
            const [instance, args] = await Promise.all([this.injector.invoke(token, scope.$ctx.container), getArguments(scope)]);
            const handler = instance[propertyKey].bind(instance);
            return handler(...args, scope.$ctx);
        };
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformParams.prototype, "injector", void 0);
PlatformParams = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.SINGLETON,
        imports: []
    })
], PlatformParams);
exports.PlatformParams = PlatformParams;
//# sourceMappingURL=PlatformParams.js.map