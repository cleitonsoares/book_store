import { __decorate, __metadata } from "tslib";
import { Inject, Injectable, InjectorService, ProviderScope } from "@tsed/di";
import { JsonEntityStore, JsonParameterStore } from "@tsed/schema";
import { ParamValidationError } from "../errors/ParamValidationError.js";
import { ParseExpressionPipe } from "../pipes/ParseExpressionPipe.js";
/**
 * Platform Params abstraction layer.
 * @platform
 */
let PlatformParams = class PlatformParams {
    async getPipes(param) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        const map = (token) => this.injector.invoke(token);
        const promises = await Promise.all([ParseExpressionPipe, ...param.pipes.sort(sort)].map(map));
        return promises.filter(Boolean);
    }
    async compile(entity) {
        const params = JsonParameterStore.getParams(entity.target, entity.propertyKey);
        const argsPipes = await Promise.all(params.map(async (param) => {
            return {
                param,
                pipes: await this.getPipes(param)
            };
        }));
        return (scope) => {
            const promises = argsPipes.map(({ param, pipes }) => {
                return this.getArg(scope, pipes, param);
            });
            return Promise.all(promises);
        };
    }
    async getArg(scope, pipes, param) {
        return pipes.reduce(async (value, pipe) => {
            value = await value;
            try {
                return await pipe.transform(value, param);
            }
            catch (er) {
                throw ParamValidationError.from(param, er);
            }
        }, scope);
    }
    async compileHandler(metadata) {
        const { token, propertyKey, getCustomArgs } = metadata;
        const provider = this.injector.getProvider(token);
        const getArguments = getCustomArgs || (await this.compile(JsonEntityStore.fromMethod(token, propertyKey)));
        if (!provider || !provider.scope || provider.scope === ProviderScope.SINGLETON) {
            const instance = await this.injector.invoke(token);
            const handler = instance[propertyKey].bind(instance);
            return async (scope) => {
                const args = await getArguments(scope);
                return handler(...args, scope.$ctx);
            };
        }
        return async (scope) => {
            const [instance, args] = await Promise.all([this.injector.invoke(token, scope.$ctx.container), getArguments(scope)]);
            const handler = instance[propertyKey].bind(instance);
            return handler(...args, scope.$ctx);
        };
    }
};
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], PlatformParams.prototype, "injector", void 0);
PlatformParams = __decorate([
    Injectable({
        scope: ProviderScope.SINGLETON,
        imports: []
    })
], PlatformParams);
export { PlatformParams };
//# sourceMappingURL=PlatformParams.js.map