"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonEntityStore = exports.JsonEntitiesContainer = void 0;
const core_1 = require("@tsed/core");
/**
 * @ignore
 */
exports.JsonEntitiesContainer = new Map();
class JsonEntityStore {
    constructor(options) {
        this.isStore = true;
        const { target, propertyKey, descriptor, index, decoratorType } = options;
        this.target = target;
        this.propertyKey = propertyKey;
        this.propertyName = String(propertyKey);
        this.descriptor = descriptor;
        this.index = index;
        this.decoratorType = decoratorType;
        this.token = target;
        this.store = options.store;
        this.parent = this;
    }
    /**
     * Return the class name of the entity.
     * @returns {string}
     */
    get targetName() {
        return (0, core_1.nameOf)(this.token);
    }
    /**
     *
     * @returns {boolean}
     */
    get isCollection() {
        return !!this.collectionType;
    }
    /**
     *
     * @returns {boolean}
     */
    get isArray() {
        return (0, core_1.isArrayOrArrayClass)(this.collectionType);
    }
    /**
     *
     * @returns {boolean}
     */
    get isPrimitive() {
        return (0, core_1.isPrimitiveOrPrimitiveClass)(this._type);
    }
    /**
     *
     * @returns {boolean}
     */
    get isDate() {
        return (0, core_1.isDate)(this.computedType);
    }
    /**
     *
     * @returns {boolean}
     */
    get isObject() {
        return (0, core_1.isObject)(this.computedType);
    }
    /**
     *
     */
    get isClass() {
        return (0, core_1.isClass)(this.computedType);
    }
    /**
     * Return the JsonSchema
     */
    get schema() {
        return this._schema;
    }
    get nestedGenerics() {
        return this.schema.nestedGenerics;
    }
    set nestedGenerics(nestedGenerics) {
        this.schema.nestedGenerics = nestedGenerics;
    }
    /**
     *
     * @returns {Type<any>}
     */
    get type() {
        return this._type;
    }
    /**
     * Get original type without transformation
     * @param value
     */
    set type(value) {
        this._type = value;
        this.build();
    }
    /**
     * Return the itemSchema computed type. if the type is a function used for recursive model, the function will be called to
     * get the right type.
     */
    get computedType() {
        return this.itemSchema.getComputedType();
    }
    get itemSchema() {
        return this.isCollection ? this.schema.itemSchema() : this.schema;
    }
    get parentSchema() {
        return this.parent.schema;
    }
    static from(...args) {
        if (args[0].isStore) {
            return args[0];
        }
        const target = args[0];
        if (args.length > 1) {
            args[0] = (0, core_1.prototypeOf)(args[0]);
        }
        const store = core_1.Store.from(...args);
        if (!store.has("JsonEntityStore")) {
            const decoratorType = (0, core_1.decoratorTypeOf)(args);
            const entityStore = exports.JsonEntitiesContainer.get(decoratorType);
            // istanbul ignore next
            if (!entityStore) {
                throw Error("Unsupported json entity type");
            }
            const jsonSchemaStore = new entityStore({
                store,
                decoratorType,
                target: (0, core_1.classOf)(target),
                propertyKey: args[1],
                index: typeof args[2] === "number" ? args[2] : undefined,
                descriptor: typeof args[2] === "object" ? args[2] : undefined
            });
            jsonSchemaStore.build();
            store.set("JsonEntityStore", jsonSchemaStore);
        }
        return store.get("JsonEntityStore");
    }
    static fromMethod(target, propertyKey) {
        return this.from(target, propertyKey, (0, core_1.descriptorOf)(target, propertyKey));
    }
    get(key, defaultValue) {
        return this.store.get(key, defaultValue);
    }
    set(key, value) {
        return this.store.set(key, value);
    }
    buildType(type) {
        if ((0, core_1.isCollection)(type)) {
            this.collectionType = type;
        }
        else {
            this._type = type;
            // issue #1534: Enum metadata stored as plain object instead of String (see: https://github.com/tsedio/tsed/issues/1534)
            if (this._type && (0, core_1.isPlainObject)(this._type)) {
                this._type = String;
            }
        }
    }
}
exports.JsonEntityStore = JsonEntityStore;
//# sourceMappingURL=JsonEntityStore.js.map