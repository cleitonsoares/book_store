import { classOf, decoratorTypeOf, descriptorOf, isArrayOrArrayClass, isClass, isCollection, isDate, isObject, isPlainObject, isPrimitiveOrPrimitiveClass, nameOf, prototypeOf, Store } from "@tsed/core";
/**
 * @ignore
 */
export const JsonEntitiesContainer = new Map();
export class JsonEntityStore {
    constructor(options) {
        this.isStore = true;
        const { target, propertyKey, descriptor, index, decoratorType } = options;
        this.target = target;
        this.propertyKey = propertyKey;
        this.propertyName = String(propertyKey);
        this.descriptor = descriptor;
        this.index = index;
        this.decoratorType = decoratorType;
        this.token = target;
        this.store = options.store;
        this.parent = this;
    }
    /**
     * Return the class name of the entity.
     * @returns {string}
     */
    get targetName() {
        return nameOf(this.token);
    }
    /**
     *
     * @returns {boolean}
     */
    get isCollection() {
        return !!this.collectionType;
    }
    /**
     *
     * @returns {boolean}
     */
    get isArray() {
        return isArrayOrArrayClass(this.collectionType);
    }
    /**
     *
     * @returns {boolean}
     */
    get isPrimitive() {
        return isPrimitiveOrPrimitiveClass(this._type);
    }
    /**
     *
     * @returns {boolean}
     */
    get isDate() {
        return isDate(this.computedType);
    }
    /**
     *
     * @returns {boolean}
     */
    get isObject() {
        return isObject(this.computedType);
    }
    /**
     *
     */
    get isClass() {
        return isClass(this.computedType);
    }
    /**
     * Return the JsonSchema
     */
    get schema() {
        return this._schema;
    }
    get nestedGenerics() {
        return this.schema.nestedGenerics;
    }
    set nestedGenerics(nestedGenerics) {
        this.schema.nestedGenerics = nestedGenerics;
    }
    /**
     *
     * @returns {Type<any>}
     */
    get type() {
        return this._type;
    }
    /**
     * Get original type without transformation
     * @param value
     */
    set type(value) {
        this._type = value;
        this.build();
    }
    /**
     * Return the itemSchema computed type. if the type is a function used for recursive model, the function will be called to
     * get the right type.
     */
    get computedType() {
        return this.itemSchema.getComputedType();
    }
    get itemSchema() {
        return this.isCollection ? this.schema.itemSchema() : this.schema;
    }
    get parentSchema() {
        return this.parent.schema;
    }
    static from(...args) {
        if (args[0].isStore) {
            return args[0];
        }
        const target = args[0];
        if (args.length > 1) {
            args[0] = prototypeOf(args[0]);
        }
        const store = Store.from(...args);
        if (!store.has("JsonEntityStore")) {
            const decoratorType = decoratorTypeOf(args);
            const entityStore = JsonEntitiesContainer.get(decoratorType);
            // istanbul ignore next
            if (!entityStore) {
                throw Error("Unsupported json entity type");
            }
            const jsonSchemaStore = new entityStore({
                store,
                decoratorType,
                target: classOf(target),
                propertyKey: args[1],
                index: typeof args[2] === "number" ? args[2] : undefined,
                descriptor: typeof args[2] === "object" ? args[2] : undefined
            });
            jsonSchemaStore.build();
            store.set("JsonEntityStore", jsonSchemaStore);
        }
        return store.get("JsonEntityStore");
    }
    static fromMethod(target, propertyKey) {
        return this.from(target, propertyKey, descriptorOf(target, propertyKey));
    }
    get(key, defaultValue) {
        return this.store.get(key, defaultValue);
    }
    set(key, value) {
        return this.store.set(key, value);
    }
    buildType(type) {
        if (isCollection(type)) {
            this.collectionType = type;
        }
        else {
            this._type = type;
            // issue #1534: Enum metadata stored as plain object instead of String (see: https://github.com/tsedio/tsed/issues/1534)
            if (this._type && isPlainObject(this._type)) {
                this._type = String;
            }
        }
    }
}
//# sourceMappingURL=JsonEntityStore.js.map