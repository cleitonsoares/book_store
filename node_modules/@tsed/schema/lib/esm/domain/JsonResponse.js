import { mapHeaders } from "../utils/mapHeaders.js";
import { toJsonMapCollection } from "../utils/toJsonMapCollection.js";
import { JsonMap } from "./JsonMap.js";
export class JsonMedia extends JsonMap {
    constructor() {
        super(...arguments);
        this.groups = [];
    }
    schema(schema) {
        this.set("schema", schema);
        return this;
    }
    examples(examples) {
        this.set("examples", examples);
        return this;
    }
    toJSON(options = {}) {
        return super.toJSON({ ...options, groups: this.groups });
    }
}
export class JsonResponse extends JsonMap {
    constructor(obj = {}) {
        super(obj);
        this.content(obj.content || {});
    }
    description(description) {
        this.set("description", description);
        return this;
    }
    headers(headers) {
        this.set("headers", mapHeaders(headers));
        return this;
    }
    content(content) {
        this.set("content", toJsonMapCollection(content, JsonMedia));
        return this;
    }
    getContent() {
        return this.get("content");
    }
    getMedia(mediaType, create = true) {
        var _a;
        create && this.addMedia(mediaType);
        return (_a = this.getContent()) === null || _a === void 0 ? void 0 : _a.get(mediaType);
    }
    addMedia(mediaType) {
        const content = this.get("content");
        if (!content.has(mediaType)) {
            content.set(mediaType, new JsonMedia());
        }
        return this;
    }
    toJSON(options = {}) {
        const response = super.toJSON(options);
        if (this.status === 204) {
            delete response.content;
        }
        if (response.headers) {
            Object.entries(response.headers).forEach(([key, { type, ...props }]) => {
                response.headers[key] = {
                    ...props,
                    schema: {
                        type
                    }
                };
            });
        }
        return response;
    }
}
//# sourceMappingURL=JsonResponse.js.map