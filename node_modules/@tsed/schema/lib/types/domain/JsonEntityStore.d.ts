import { DecoratorTypes, Store, Type } from "@tsed/core";
import type { JsonSchema } from "./JsonSchema";
import type { JsonMethodStore } from "./JsonMethodStore";
import type { JsonClassStore } from "./JsonClassStore";
import type { JsonPropertyStore } from "./JsonPropertyStore";
import type { JsonParameterStore } from "./JsonParameterStore";
/**
 * @ignore
 */
export declare const JsonEntitiesContainer: Map<DecoratorTypes, Type<JsonEntityStore>>;
export interface JsonEntityStoreOptions {
    decoratorType: DecoratorTypes;
    target: Type<any>;
    propertyKey?: string | symbol;
    index?: number;
    descriptor?: any;
    type?: Type<any>;
    collectionType?: Type<any>;
    beforeMiddlewares?: Function[];
    middlewares?: Function[];
    afterMiddlewares?: Function[];
    [key: string]: any;
}
export declare abstract class JsonEntityStore implements JsonEntityStoreOptions {
    /**
     * Original property key decorated by the decorator
     */
    readonly propertyKey: string | symbol;
    /**
     * Alias of the property
     */
    readonly propertyName: string;
    /**
     * Parameter index
     */
    readonly index: number;
    /**
     * Method's descriptor
     */
    readonly descriptor: number;
    /**
     * Decorator type used to declare the JsonSchemaStore.
     */
    readonly decoratorType: DecoratorTypes;
    /**
     * Type of the collection (Array, Map, Set, etc...)
     */
    collectionType: Type<any>;
    token: Type<any>;
    readonly store: Store;
    readonly isStore = true;
    readonly parent: JsonEntityStore;
    readonly target: Type<any>;
    /**
     *
     */
    protected _type: Type<any>;
    /**
     * Ref to JsonSchema
     */
    protected _schema: JsonSchema;
    [key: string]: any;
    constructor(options: JsonEntityStoreOptions);
    /**
     * Return the class name of the entity.
     * @returns {string}
     */
    get targetName(): string;
    /**
     *
     * @returns {boolean}
     */
    get isCollection(): boolean;
    /**
     *
     * @returns {boolean}
     */
    get isArray(): boolean;
    /**
     *
     * @returns {boolean}
     */
    get isPrimitive(): boolean;
    /**
     *
     * @returns {boolean}
     */
    get isDate(): boolean;
    /**
     *
     * @returns {boolean}
     */
    get isObject(): boolean;
    /**
     *
     */
    get isClass(): boolean;
    /**
     * Return the JsonSchema
     */
    get schema(): JsonSchema;
    get nestedGenerics(): Type<any>[][];
    set nestedGenerics(nestedGenerics: Type<any>[][]);
    /**
     *
     * @returns {Type<any>}
     */
    get type(): Type<any> | any;
    /**
     * Get original type without transformation
     * @param value
     */
    set type(value: Type<any> | any);
    /**
     * Return the itemSchema computed type. if the type is a function used for recursive model, the function will be called to
     * get the right type.
     */
    get computedType(): any;
    get itemSchema(): JsonSchema;
    get parentSchema(): JsonSchema;
    /**
     *
     * @param target
     */
    static from<T extends JsonClassStore = JsonClassStore>(target: Type<any>): T;
    static from<T extends JsonPropertyStore = JsonPropertyStore>(target: Type<any> | any, propertyKey: string | symbol): T;
    static from<T extends JsonParameterStore = JsonParameterStore>(target: Type<any> | any, propertyKey: string | symbol, index: number): T;
    static from<T extends JsonMethodStore = JsonMethodStore>(target: Type<any> | any, propertyKey: string | symbol, descriptor: PropertyDescriptor): T;
    static from<T extends JsonEntityStore = JsonEntityStore>(...args: any[]): T;
    static fromMethod<T extends JsonMethodStore = JsonMethodStore>(target: any, propertyKey: string | symbol): T;
    get<T = any>(key: string, defaultValue?: any): T;
    set(key: string, value?: any): Store;
    protected abstract build(): void;
    protected buildType(type: any): void;
}
