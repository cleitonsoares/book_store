"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeORMModule = void 0;
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const typeorm_1 = require("typeorm");
const TypeORMService_1 = require("./services/TypeORMService");
const WHITELIST = [typeorm_1.Repository, typeorm_1.AbstractRepository];
class TypeORMModule {
    constructor(configuration, typeORMService) {
        this.typeORMService = typeORMService;
        this.settings = configuration.get("typeorm", []);
    }
    async init() {
        const promises = this.settings.map((opts) => this.typeORMService.createConnection(opts));
        return Promise.all(promises);
    }
    $onDestroy() {
        return this.typeORMService.closeConnections();
    }
}
exports.TypeORMModule = TypeORMModule;
function isRepository(type) {
    const ancestors = (0, core_1.ancestorsOf)(type);
    return ((0, core_1.isClass)(type) &&
        ancestors.find((ancestor) => {
            return WHITELIST.includes(ancestor);
        }));
}
(0, di_1.registerProvider)({
    provide: TypeORMModule,
    deps: [di_1.Configuration, TypeORMService_1.TypeORMService, di_1.InjectorService],
    resolvers: [
        {
            deps: [TypeORMModule],
            get(type, options) {
                if (isRepository(type)) {
                    try {
                        return (0, typeorm_1.getCustomRepository)(type, options.connection || "default");
                    }
                    catch (er) {
                        if (process.env.NODE_ENV !== "test") {
                            throw er;
                        }
                    }
                }
            }
        }
    ],
    injectable: false,
    async useAsyncFactory(configuration, typeORMService, injector) {
        (0, typeorm_1.useContainer)({
            get(type) {
                return injector.hasProvider(type) ? injector.get(type) : undefined;
            }
        }, { fallback: true });
        const typeORMModule = new TypeORMModule(configuration, typeORMService);
        await typeORMModule.init();
        return typeORMModule;
    }
});
//# sourceMappingURL=TypeORMModule.js.map